--print('= REGION:')

local R = {}
local ui = {
	spacing = 3,
}
local out = {apath = {}}

local aside

local D, W

local im = ui_imgui

local U = require('/lua/ge/extensions/editor/gen/utils')

local function lo(ms)
	if true then return end
	print(ms)
end


local _DBG = false

if false and U._PRD == 0 then
	-- rcPave test
--    U.camSet({-269.09, 1168.84, 10.02, 0.00727413, 0.266802, -0.963366, 0.0262654})
--    U.camSet({-259.00, 1134.89, 18.49, 0.334514, -0.000617093, 0.0017385, 0.942389})
	U.camSet({-259.80, 1129.02, 11.99, 0.244778, 0.0707423, -0.268479, 0.928977})
	-- small_island
--    U.camSet({-3351.02, 3728.87, 1090.49, -0.267073, 0.282016, -0.669075, -0.633623})
--    U.camSet({-263.28, 1133.29, 8.87, 0.188709, 0.00497243, -0.0258669, 0.98168})

	-- for AAA-tech world
--    U.camSet({-269.79, 1159.12, 8.55, 0.0924085, -0.152066, 0.840943, 0.51103})
--    U.camSet({-259.00, 1134.89, 18.49, 0.334514, -0.000617093, 0.0017385, 0.942389})
--    U.camSet({-258.63, 1166.98, 8.65, -0.0246537, 0.163646, -0.975207, -0.146912})
--    U.camSet({266.57, 333.84, 22.01, -0.000111994, -0.139468, 0.990226, -0.000801391})
--    U.camSet({-250.51, 1169.23, 7.18, 0.0457479, 0.187827, -0.953267, 0.232186})
--    U.camSet({-212.31, 1145.78, 8.67, 0.0733737, 0.214645, -0.921574, 0.315032})
--    U.camSet({-176.84, 1093.29, 35.79, 0.273329, 0.0845505, -0.283164, 0.915402})
end


if false and U._PRD == 0 then
	U.camSet(
-- [4.94, 5.54, 421.12, -0.129456, -0.122583, 0.676553, -0.714487]
--        {-224.40, 1154.63, 168.03, 0.388892, 0.389779, -0.590941, 0.589596}
---        {-252.74, 1154.57, 101.84, 0.388892, 0.389779, -0.590941, 0.589596}
--        {-172.18, 1111.36, 168.14, 0.394757, 0.198883, -0.403592, 0.801078}
--        {189.46, 1192.32, 170.80, -0.0386253, -0.350145, 0.930256, -0.102619}
--        {-222.28, 1077.29, 656.70, -0.407358, 0.283313, -0.495727, -0.712775}
--        {-146.88, 1117.08, 407.68, -0.528661, 0.0586891, -0.0934333, -0.841632}
		{-219.48, 1036.43, 161.67, 0.371516, -0.105222, 0.25137, 0.887534}  -- tech
--        {-183.94, 1174.32, 503.76, -0.0282063, 0.475835, -0.877542, -0.0520179} -- AAA
--        {215.68, 823.09, 391.00, -0.242226, 0.0422517, -0.166561, -0.954881}
	--    {-778.29, 1067.23, 245.61, 0.280473, -0.120106, 0.374881, 0.875427}
	)
		lo('??*************************** cam_SET')
end

local adec
local cpoint

local margin = 2
local mm_len = {10., 20.} -- front wall length interval
local mm_depth = {6., 16.}
local mm_space = {1.5, 4} -- distance between buildings

local abase = {}
local abound = {}
local across = {}

local aswitch = {}

local anobj
local n2d
local dn2d = {} -- side index -> node2depth_map


local function forMedian(sfr, sto)
	local vfr = adec[sfr.rd].list[sfr.to - (sfr.to > sfr.fr and 1 or -1)] - adec[sfr.rd].list[sfr.to]
	local vto = adec[sto.rd].list[sto.fr + (sto.to > sto.fr and 1 or -1)] - adec[sto.rd].list[sto.fr]
--        lo('>>_____------______ forMedian:'..vfr:cross(vto).z)
	local dir = vfr:cross(vto).z > 0 and -1 or 1
	return dir*(U.proj2D(vfr):normalized() + U.proj2D(vto):normalized()):normalized()
end


-- tip = 0/1 - start/end
local function toStem(p, side, tip)
	local v
	local dir = side.to > side.fr and 1 or -1
	local corner = (tip == 0 and adec[side.rd].list[side.fr] or adec[side.rd].list[side.to])
	if tip == 0 then
		v = adec[side.rd].list[side.fr + dir] - corner
	else
		v = adec[side.rd].list[side.to - dir] - corner
	end
	return (p - corner):dot(v:normalized())
end


local function cornerPrev(c)
--        U.dump(c, '>> cornerPrev:')
	local dir = c.dir
	local ri,ni = c.rd,c.fr
	--            local ri,ni = c.rd,c.to
	if not across[ri] or not across[ri][ni] then return end
--        lo('?? for_crn:'..tostring(across[ri][ni]))
	local astem,us = U.clone(across[ri][ni])
	astem[#astem + 1] = {ri, ni}

	local star = U.forStar(astem, adec)
	for i,s in pairs(star) do
		if s.rdi == ri and s.ndi == s.fr + dir then
			-- take prev branch
			return star[(i) % #star + 1]
		end
	end
end


local acLen = {}

local aLen = {
--    12.085117187255,13.648800094462,15.235913458081,19.00177369688,17.376175350086,13.802192552124,14.233119338793,13.212528258815,10.621803307693,14.003031807105,13.278460269328,18.508333780406,12.045385741225,12.736869163304,16.967145168343,12.563031286654,14.825912370564,17.643497931906,13.396420803582,18.096061174883,12.617470111004,14.149879270779,13.955910774797,16.993841285102,10.437989308173,16.593376416262,14.68193686695
--    12.085117187255,13.648800094462,15.235913458081,19.00177369688,17.376175350086,13.802192552124,14.233119338793,13.212528258815,10.621803307693,14.003031807105,13.278460269328,18.508333780406,12.045385741225,12.736869163304,16.967145168343,12.563031286654,14.825912370564,17.643497931906,13.396420803582,18.096061174883,12.617470111004,14.149879270779,13.955910774797,16.993841285102,10.437989308173,16.593376416262,14.68193686695
--    17.212918636623,19.097876356215,19.17158757826,17.190091858844,13.312385810821,15.026681867438,15.615770353867,18.105821467001,19.067153496632,11.912319941833,14.31882015828,13.401503559768
--    13.834369247337,10.115993927039,10.165525302306,15.816250464257,19.401407454001,11.259647774969,14.081342648257,10.940613707623,15.651268714923,15.319798959573,17.504354518754,12.398500102716,14.135191135402,13.966777974011,14.604188648045,19.216888173712,13.508429319088,16.078785612055,10.245614019507,13.300081019751,12.379809798254,18.825189011617,17.712392939049,12.469156987404
--    15.688509346918,16.496812678868,18.135424188731,10.808679450347,16.180364814622,19.632858609239,15.160905279034,14.131758147776,10.861729160485,16.953857176228,10.959072311734,14.840106094477,14.017583180309,17.170352656923,18.267413840226,18.306464854805,11.412160529083,15.812000866433,17.658292219827,19.771381980435,13.2801934125,17.477971900695
--    18.890654374657,13.104638766977,16.076794836736,13.668161400904,18.336608372222,19.092399724594,10.272549944669,14.475192026951,17.86310815778,12.780168429516,10.45237269161,13.435950602238,19.416449971278,12.50436043524,14.425527882242,16.967108860322,16.592470191067,14.965595274823,16.682586917334,10.462012199916,11.776623981478,19.194772796402,16.991132657614
--    12.799345897654,18.116445973368,19.53408939966,18.913906833459,14.664179729001,17.693277668922,18.443221069004,17.855179160001,12.150387569892,17.256170650794,18.226595079503,12.436288067235,16.787107676122,11.35458828279,16.971886084858,18.985508895695,13.338791220658,10.641229781748,17.092807605644,15.309315011036
--    19.217963617161,17.434841263242,13.496849419175,17.772980650086,17.949140891235,10.145600238629,10.759913575496,12.303371014598,16.443253511799,13.227921709234,17.194910660751,15.444579785014,16.436982570167,17.445861592941,18.98906299261,13.258140274821,10.829706779664,17.009859818126,16.178936711921,11.321570805073,12.391496032672,19.583362847237,18.192170879909
--    15.104233715197,13.769955425749,11.37745590289,12.359360894958,12.853975914433,10.887045825507,19.224462045645,10.137007339161,16.135237584416,12.318402664459,17.764793012804,17.785477797543,18.423975377624,16.135078060643,17.707955690515,16.047763500466,13.848752917462,19.233771521913,10.592342823854,19.894399174554,19.413208069083,16.400880007838,15.136589017178,11.441945722072
--    13.788172276307,18.121157337234,16.14900554432,12.122308501045,14.01688117247,16.353389058277,10.812969524182,14.476240309441,14.475167126173,18.11219560757,13.252304018653,12.729324258465,10.252304755227,12.730569116594,15.178891879851,15.134722906691,11.209105647839,10.329893658905,15.004147171289,17.485483956675,12.091741874994,12.150986611183,12.696990296589,12.578635151998
--    16.578853562911,11.253043547835,18.105784422942,13.232036000165,13.348121880164,10.959571755901,10.989227686276,19.821942963949,12.732570387618,10.547893544511,12.199668660895,12.808625509357,14.209332205645,16.243038605847,15.885312584,18.412771605195,15.536269994599,13.467137506448,16.601919747253,10.166981646595,14.177112645028,17.187227636419,16.759597105362,18.156651115264,14.909094869499,13.772440127018,16.87290779016,16.70102112703,12.108469865263,13.475716900372,18.32457034311
--    18.747385166138,16.797157003819,19.682467589824,10.091588102494,12.749093655447,13.382061148834,10.735519746571,14.268528886461,13.999869100042,13.48062962495,11.968841331736,12.309946769875,13.456527769308,14.472224804178,11.013555571079,17.526942848549,16.637049609793,13.265358867223,19.554493860383,15.477863298008,14.136351379064,19.196756272362,16.346484902575
--    10.031444622961,15.889645041171,18.256433283666,11.15823282913,16.852643372514,19.250106761836,16.605705099035,13.85585501997,17.711266014187,17.972617115201,15.828290994996,11.469352999441,19.772341538481
--    15.105230742156,16.538125242543,19.89014433986,14.926865426653,12.687153170897,10.978622754866,12.007632600983,14.67815215066,19.682224995908,18.288487856443,18.594240212367,15.208272153173,18.425895046002
--    15.289247126947,10.916632452658,13.11066055472
--    19.952361820994,14.272851431879,18.613927102556,11.574247550683,18.820194691276,18.973604200665
--    17.844762672325,10.74328485986,18.275073616451,19.534183003748,12.909956440628,19.859423425779,17.813218784261,16.433606545281,18.735609148005,18.226969531715
--    13.538625911484,15.685656834399,14.03568002953,19.327653071349,15.935068737567,10.842435113725,17.097901961791,11.443477791099,19.445516220208,19.781141052289,13.885139875902,12.243056847007,19.690008606738,13.22778420139,12.696325821234,10.3882659001,15.635210824243,19.782946567679,10.258318476274,16.654216795834,19.422308225881,11.348847691228,18.240547539986,16.02060024127,18.03578422418
--    11.34046116234,10.282025778426,16.50757948014,18.380970845742,17.956683282278,16.076400903383,13.636111913206,17.26277771745,13.014262287831,19.237543932441,16.008976896726,18.945142589537,19.851259176994,19.948210028738,13.371586849803,10.356815961465,17.372728939877,16.151450243994,10.252724313962,10.924284190845,18.248883698506,19.938667374732,17.065367360013
--    11.453138205095,13.84594207422,19.933147397085,10.687827858332,14.282458600944,10.792049679237,18.282895939444,14.970967901234,13.431472257555,13.34496161048,10.890564075811,12.822596983879,17.427273353946,15.069578456714,14.18332340648,18.638448623484,18.168670966107,19.726750586357,10.161308995923,11.59973427338,18.586784135429,16.041015236755,12.408274516932,18.224002787021,10.613580429737
--    16.70966305108,15.937318368418,19.873171259859,12.995366040516,12.425461911973,11.124537697479,17.404275544287,16.020158546515,17.887424197201,14.305419896508,12.325704511553,11.919503304537,11.376010496007,16.368470402388,12.419069358809,19.06775308326,15.648584431247,10.631334686139,17.79870421322,18.63209881975,17.372825859989,15.651802322471,12.824454146128
--    12.090992267025,18.737061981787,15.53193921561,13.200574527865,19.704219290334,11.575421729989,11.729206764036,18.133238465449,19.621802960993,11.858606150849
--    12.904300874949,11.600394262283,19.1364565424,17.641672722529,11.737720876705
--    14.501124412579,19.71892488937,15.734185537672,14.157164758191,11.867167746484,18.577703856623,18.040012592767,12.769430569192,18.06100441062,10.063510431577,13.785841167436,17.709825517211,11.510887132652,17.912024371607,14.566343465313,17.182248184698,15.648287939942,18.061788434405,12.568226026745,13.778171686667,11.196960647255,16.339863056654,11.510408174745,18.644156717029,13.708862797842
--    17.675882223764,16.619927120499,10.712298668423,19.444078218888,19.486109731148,14.264852669544,18.846157543255,11.376726910072,14.467841635428,19.224293771287,11.893883406549,10.984578590671,16.407466190288,16.565380304758,16.568313124975,11.222990001243,15.754965717278,14.925618445621,16.108682807832,10.530885220917,15.011959857244,19.703398298596,13.911330245734,16.589891106983
--    19.281679402478,18.560610511191,11.889105011165,14.61256512837,16.451813542589,12.679875403311,12.393877664394,14.346931635871,16.443402045979,15.784818267779,15.407089888311,10.445762972271,16.854120520759,17.432891994497,17.133591631991,10.017204026272,16.275692376365,19.689917574535,10.659935222254,11.224550570528,10.262126769943,17.111691132635,18.250433667303,11.389131562462,10.152144755674
--    10.152144755674,16.45739390426,12.51941434429,10.392996328026,16.90491295453,12.489804416878,10.113030548197,16.220865514991,16.566564694966,11.275876098186,16.045238641555,13.914736032568,11.137680858796,15.810493527483,15.57450331918,12.331996226601,19.142072490123,14.422035882195,13.063148860516,13.187450223767,12.925083608521,14.457650422091,14.034124564506,18.526482158603,14.158542081997,18.670572860087
--    15.496488405595,16.45752512381,18.247893089339,19.639804362273,10.688284835924,12.322259422186,12.826370746215,17.935252827498,11.314706066934,17.204850316467,10.623104968871,10.227342582243,13.538711584782,10.350799764045,18.922670669896,12.001925327452,19.980113143672
--    14.504879057416,18.144978758446,19.337039924808,11.405685138425,14.018112115825,15.561748983649,10.766472043939,14.533397562137,13.904004976198,19.27124188802,16.095256668858,13.453146131284,10.472812615164,17.808973352527,14.59516896634,12.913835130681,16.740128010961,11.263135769578,16.158038295139,11.155021786962,12.339980992781,17.805783089514
--    14.356190967903,10.541527624936,13.476471602162,14.398999452801,10.731580311794,13.081812776412,13.425039152513,14.033986557915,19.507330507957,11.005923095731,18.134342512108,14.492012725026,17.89749308459,18.537686010501,12.88132804311,19.403416147839,16.784556889343,15.197143099472,15.117270558358,15.910404273174,12.679222879226,16.384938220574,16.51022317207,16.534572632415,16.89886898378,18.073431160655,14.63836999457,18.200382863642,16.24103911209,14.774533905298,15.531930299956,19.833260738247,18.981086601043,19.851716525002,15.153498016576,13.163021449368,18.813829674665,10.360013864386,12.919845269953,18.074868321324,17.005004970189,18.207068830926,16.63126446736,11.757611433798,11.653774997375,17.503040095378,15.755735502148,16.222359865947,10.741017382738,16.427858135892,18.466990494396,16.988972756739,14.155867532382,16.002858666007,14.827075245941,13.965409159393,16.208133874808,10.967117642827,17.339024185338,12.566998361002,13.611158338526,18.329213687868,12.271230595026,14.701956796655,10.309209807936
--    13.965409159393,16.208133874808,10.967117642827,17.339024185338,12.566998361002,13.611158338526,18.329213687868,12.271230595026,14.701956796655,10.309209807936,11.632231265627,17.925798179998,12.050381001408
--    14.449406000283,16.930978143419,11.248732575342,10.578357431941,18.914727544558,14.17897634649,17.996738545614,19.311508957912,19.262694996041,14.212904840688,19.238403941012,19.180054387826,14.635462134745,15.142174557541,10.617063219431,13.865671878264,10.19591057549
--    14.17897634649,17.996738545614,19.311508957912,19.262694996041
--    14.17897634649,17.996738545614,19.311508957912,19.262694996041,17.76043242465,16.132990820488,10.541849174403,15.783785438763,10.386446596444,18.186813340313,10.495051376915,19.042322470802,18.103966816896,19.112005900269,12.556055933552,18.130091010029,12.951100343608,10.35615059445,14.559117354556,10.514606978635,17.312649847508,17.071670144199,14.425775342109,10.507863177419,11.634255135454
--    13.176097694625,18.876169178173,17.330810937371,11.817652458307,12.026783691329,18.462327914237,18.548672186893,13.841879943566,15.425863275787,10.582929385444,16.748996352147,19.824240332752,11.274423591832,13.081536798558,19.434671523086,11.190387914737,18.052029826589,16.265010427988,19.988289999164,13.408228273066,13.880929203009,13.253235985723,16.423689079567,12.03846748982
--    13.74868287936,13.704541201701,12.553282130291,10.234243240649,14.846213901701,15.382800828929,11.143612342479,12.459296633569,12.492622511826,14.666644255269,14.110864695317,13.027153142698,19.331583323576,13.58044229489,10.219824873498,18.363558840561,14.435807940307,17.751301545413,12.175558044799,18.330696672348,19.842406655634,11.783088164074,13.576496325791,15.233614695551,16.749501370675,13.205674226821
--    14.310553368914,10.966261693545,19.017216463769,13.956228813116,15.789363677715,19.093296502848,13.865921242375,19.990948266025,18.253187328687,12.665578477157,18.455920858424,17.808620474455,12.887667359854,11.308696577406,17.046639340602,15.526015537981,18.554201795959,17.030790565141,12.733923926709,12.268226645554,13.841795326093,13.980024975042,18.230503350704,13.954393768158
--    10.361352537535,19.717258845745,13.95405262493,14.904906671087,13.36922635279,16.460579884229,17.423409486166,16.693459068741,19.975802375356,15.927215292814,11.467543272372,10.364053910348,15.142529517366,18.96973779651,12.345832350604,12.641386897553,12.081237393846,10.145973959633,10.789830651865,17.998693581197,17.682759227098,12.993345247419,19.580889599297,10.829669984076,11.295732459503,10.794333377897,19.141809965893,19.797341592174,16.142778884057
--    10.361352537535,19.717258845745,13.95405262493,14.904906671087,13.36922635279,16.460579884229,17.423409486166,16.693459068741,19.975802375356,15.927215292814,11.467543272372,10.364053910348,15.142529517366,18.96973779651,12.345832350604,12.641386897553,12.081237393846,10.145973959633,10.789830651865,17.998693581197,17.682759227098,12.993345247419,19.580889599297,10.829669984076,11.295732459503,10.794333377897,19.141809965893
--    10.331493869482,14.603060838789,12.518305507974,18.369762446495,11.479105395929,17.987990787155,11.475489710186,17.643896074183,15.376763826552,18.676259900203,18.624388966475,17.05079198458,15.288375372808,10.990310125529,10.716198856385
--    14.175903902167,14.30243924287,15.837613226294,16.684415203468,16.457263469258,15.657286173636,17.178383532979,17.380893723581,18.964595099508,17.362725230271,14.007581157228,17.552735462187,11.725415590818,10.513217298326,17.818950982168,10.635261545272
--    14.175903902167,14.30243924287,15.837613226294,16.684415203468,16.457263469258,15.657286173636,17.178383532979,17.380893723581,18.964595099508,17.362725230271,14.007581157228,17.552735462187,11.725415590818,10.513217298326,17.818950982168
--    12.296411490051,13.332430710486,15.878105272661,18.32445148395,10.843013179844,15.838876687083,18.533785497659,10.569331396119,14.847284205401,10.188162278802,15.454982242029,15.745232719631,18.031226278179,13.242450548135,11.387855996471
	12.296411490051,13.332430710486,15.878105272661,18.32445148395,10.843013179844,15.838876687083,18.533785497659,10.569331396119,14.847284205401,10.188162278802,15.454982242029,15.745232719631,18.031226278179,13.242450548135,11.387855996471,12.258384837255,10.25240129799,12.291082604443,16.149401018978,19.648910918731,19.130183254089,10.937075564593,18.25445153279,10.925840043601,17.991778997689,13.778815795898,10.227789346555
}
local clen = 1

local aSpace = {
--    3.8126416980818,3.4055439856634,3.4938670592881,3.1570975918825,1.8464577701992,2.9767443065716,3.1778350244893,3.6770616335552,2.4438737574925
--    3.9486422058692,3.3778669547572,1.8096574619532,3.9243852656713,2.3612139318652,3.7785393851336,3.7680700059533,1.6854119464709,3.9515024914622,1.7578545104379,2.8260464951232,3.7981967397256
--    2.1768638612522,3.8442911806002,2.3763704849558,3.9135494696922,3.3338790627624,2.1169166195168,3.5118990280574,2.3073472671528,2.1306162770624,3.2861594893637,1.8522628739716,2.6462624242017,2.5152923279859,2.3390257380219,3.0781670299532,3.3493250747425,2.2882416602595,1.8148924890785,3.2707483935512
--    1.5494526401989,3.1200065699198,2.1442079383713,2.0153057396976,1.6479200634244,2.6124750647678,3.4321329141173,1.7125670733693,2.3784116163284,2.1227058990681,2.6984105262664,3.8648609990089,3.5798869908305,3.2068859388638,2.9053526677455,2.2913586282136,2.5795762258441
--    3.3069290918773,3.2518190763626,3.2335001541572,3.3129875921572,2.6128570435467,2.9496427413075,3.1189343035939,1.7562389496519,3.5631580715043,2.1249197981951,2.1148143503013,2.9577440086717,1.6324085843691,3.1568641323678,2.7908826727965,2.6038290043529,3.6085167342863,2.1787729535712,2.2564411308695
--    18.671794216384,10.026854567235,10.226196889772,14.901741354805,12.483006084468,12.136637700144,13.463390492818,11.464744081475,18.643388911789,14.9237510834,17.592344671225,17.489688976371,17.638432400634,12.307941743325,15.55582980709,10.006171906577,17.17754301618,14.557351205311,14.847009742057,15.567843298366,10.441250419151,15.818313868334,18.648387285901,16.233469300806
--    2.91412453637,3.7744849295156,2.4447643790576,1.6055317369507,3.9124412089027,3.0533225570206,2.0591022625267,2.2848249530588,1.9296834685409,3.2445787676892,2.8326964575828,3.1548282950192,3.8018358806911,2.5509206502343,3.5275724885999,3.2645613360191,2.865925567627,3.0438143243816,2.0837123945754,3.4693929653648,1.9473650583537
--    3.5124804120026,2.1672081993989,2.1320696467458,3.5838417890993,3.4499204885604,2.9442372597287,1.9274662952014,1.9422553514808,2.1589199472873,3.5349335382064,3.5197268803991,2.646883050263,3.1125679981636,3.5035283863881,3.4924407505215,3.5458792107041
--    1.5418465912898,3.2464606208006,3.7654154112726,3.9379436016672,2.5329892285205,2.5905028923576,3.7591275329088,2.3391203252318,3.1213113669224,3.6934116648498,2.4288255738056,3.5343124526056,1.8912838884556,2.7789099309133,2.5159030554952,3.2440794606325,1.5919683839108,2.191143870355,3.0528729468904,1.5783116095012
--    2.2539717269907,2.3968678525509,1.505640738885,3.9654607348415,3.3706393368624,3.4698265612585,2.1069151817273,3.0911262129549,3.9366216344427,1.767569093742,2.9590853190309,2.9632946798925,3.6131175500251,3.9059112953716,2.3944196797273,1.6012071967074,1.7242208878897,3.0011072115211,1.6582376442727
--    2.9894989912164,2.500835219738,3.8854276000206,3.4937534668075,3.4823010879189,2.3659839463858,3.7809015500997,2.8838326646892,3.1301857644082,2.6648546245939,1.8672856604389,1.818534424569,2.602559988053,2.4977108824489,3.5520560822555,3.4697599112096,3.6503085053254,1.9870505275428,1.937430060077,3.0656530668875,3.6567941267653
--    1.7469847685688,1.6309126517098,2.3702761325301,1.7341810282268,3.4104751488876,3.7057729482847,1.964499427249,2.8812032577657,2.001359843403,1.8521107613063,2.5947256977505,2.1608000945961,3.0032263324872,2.1129553343114,2.2605897655579,2.7168089120639,3.8248871595379,1.7904247170756,2.0010696392121,2.8974480452797,3.9518666720047,1.5508169165028,3.6583046607851,2.7831275226358,1.6298126129609,3.1815359098964,1.7361599858723
--    3.7321399030352,2.6595439623318,3.0776277376857,1.6548410423092,3.970556230064,2.0060914930035,2.9211206249942,2.5635915947473,1.5282773144327,3.2740793995497,3.6142255724228,2.9902646458414,1.9062812120623,3.6567025026799,2.2863320676465,2.8261027588838,2.5052542315379,2.0897264431579,2.7411404054208
--    2.6618309940346,2.4156331971273,2.1072956874276,3.8705360051459,3.3753649690018,2.8211415895191,1.7444344882257,3.4714117885551,2.2761752824376
	3.2052751836009,3.4192920754806,1.7142754925265,2.0930989806092,2.1246102641105,1.9355914461223,1.7093356365601
}
local cspace = 1
local drepell = 2

--local aGen,cgen = {},1


local function forDepth(a, b, dbg)
--    lo('>> forDepth:'..#abound)
--        out.awhite = {}
--        out.agreen = {a}
	local function forCross(a,b,dir)
--                out.awhite = {}
--                out.agreen = {}
--                out.ayel = {a,b}
--                out.acyan = {}
		a = vec3(a.x,a.y)
		b = vec3(b.x,b.y)
		local fr,to,step = #abase,1,-1
		if dir < 0 then
			fr,to,step = 1,#abase,1
		end
		local spre, ppre
		local da,db,cda,cdb,cdp
		local push = {seg = nil, d = math.huge}

		if dbg then lo('?? fr_to:'..fr..':'..to..':'..step) end

		for i = fr,to,step do
			local base = U.clone(abase[i])
--                    lo('?? for_i:'..i..':'..tostring(abound[i])..':'..#abase)
			if true and abound[i] then
				base = {base[1]}
				base[#base + 1] = base[#base] + abound[i][1]
				base[#base + 1] = base[#base] + abound[i][2]
				base[#base + 1] = base[#base] - abound[i][1]
			end
--                    if true and i == fr then
--                        out.awhite = base
--                        if #abase == 3 then return end
--                    end
--            local ilast = dir > 0 and #base/2 or #base
			local ilast = dir > 0 and #base/2-1 or (#base + 1)
			local ishift = 0
			if i == fr then
				ishift = 1
			end
			for j = 3-ishift,4,1 do
--                    lo('?? for_j:'..j)
--            for j = ilast+dir*1,ilast+dir*#base/2+1,dir do
				local p = U.proj2D(base[j])
--                        out.awhite[#out.awhite+1] = p
				local s = closestLinePoints(a, b, p, p + vec3(0,0,1))
--                        lo('?? for_s:'..i..':'..j..':'..tostring(s)..'<'..tostring(spre))
				if 0 <= s and s < 1 then
--                        lo('??- for_s2:'..tostring(spre))
					cdp = p:distanceToLine(a, b)
					if not spre then
						cda = cdp
--                        lo('??-- for_s21:'..tostring(cda)..':'..tostring(da))
						if not da or cda < da then da = cda end
					elseif spre < 0 then
						-- spre is negative
						cda = ((ppre*s - p*spre)/(s-spre) - a):length()
--                        lo('??-- for_s22:'..tostring(cda)..':'..tostring(da))
						if not da or cda < da then da = cda end
					end
--                        lo('?? da_cdp:'..tostring(da)..':'..tostring(spre))
					da = math.min(da,cdp)
					if da < push.d then
						push  = {d = da, seg = {p, ppre}}
					end
				end
				if s > 1 then
--                    lo('??- for_s3:'..tostring(spre))
					if spre then
						if spre < 0 then
							-- set d_a
							cda = ((ppre*s - p*spre)/(s-spre) - a):length()
--                            lo('??-- for_s31:'..tostring(cda))
							if not da or cda < da then da = cda end
							if da < push.d then
								push  = {d = da, seg = {p, ppre}}
							end
						end
						-- set d_b
						cdb = ((ppre*(s-1) + p*(1-spre))/(s-spre) - b):length()
--                            lo('??-- for_s32:'..i..':'..j..':'..tostring(cdb))
--                            out.acyan = {p}
--                            out.agreen = {ppre}
						if not db or cdb < db then db = cdb end
						if db < push.d then
							push  = {d = db, seg = {p, ppre}}
						end
					end
				end
				ppre = p
				spre = s
				if da and db then
					break
--                    return math.min(da, db)
				end
			end
			if da and db then
				break
			end
		end
--            U.dump(push, '?? pre_ret: da:'..tostring(da)..' db:'..tostring(db))
		if not da then da = math.huge end
		if not db then db = math.huge end

		local dh = 0
		if push.seg and #push.seg == 2 then
			dh = drepell/math.abs(math.cos(U.vang(b-a, push.seg[2]-push.seg[1])))
		end
		return math.min(da, db) - dh
	end
	local d = forCross(a,b,1)
--    lo('<< forDepth:'..tostring(d))

	return d
end
--[[

				if not spre or 0 <= s then
--                    local d =
				end

				if ppre then
					local s = closestLinePoints(ppre, p, a, a + vec3(0,0,1))
					if 0 <= s and s < 1 then
						local d = a:distanceToLineSegment(ppre, p)
						if not da or d < da then da = d end
					end
					s = closestLinePoints(ppre, p, b, b + vec3(0,0,1))
					if 0 <= s and s < 1 then
						local d = b:distanceToLineSegment(ppre, p)
						if not db or d < db then db = d end
					end
					if da and db then return math.min(da,db)
				end
				ppre = p
]]


local function line2side(line, side)
	local anode = adec[side.rd].list
	for ni = side.fr+side.dir,side.to,side.dir do
		local x,y = U.lineCross(anode[ni],anode[ni-side.dir],line[1],line[2])
		local s = closestLinePoints(
			anode[ni-side.dir], anode[ni],
			vec3(x,y), vec3(x,y)+vec3(0,0,1)
		)
--            lo('?? for_s:'..ni..':'..s)
		if 0 <= s and s < 1 then
			lo('?? cross_hit:'..ni)
--            out.ayel = {anode[ni-side.dir]*(1-s) + anode[ni]*s}

			return anode[ni-side.dir]*(1-s) + anode[ni]*s,
				U.vang(anode[ni] - anode[ni-side.dir], line[2]-line[1])
		end
	end
	return
end


local function p2dist(side, ni, s)
	local last = side.dir < 0 and n2d[side.fr].d or 0
	if ni == side.fr then return end
	return (last + side.dir*n2d[ni - side.dir].d)*s + (last + side.dir*n2d[ni].d)*(1-s)
end


local function p2side(p, side, start, dbg)
--        U.dump(side, '>> p2side:'..tostring(p)..':'..start)
	if not start then start = side.fr end
	local anode = adec[side.rd].list
	local dprev
			if dbg then
				U.dump(side, '?? p2side:'..start..':'..side.dir..':'..side.fr..'>'..side.to)
			end
--    for ni =
	local vp,d,pos
	local prd,s
--            lo('?? prep:'..start..':'..(side.to-side.dir)..':'..side.dir)
	local ito,step = side.to-side.dir,side.dir
	if start == side.to then
		ito,step = side.fr,-side.dir
	end
	for ni = start,ito,step do
--    for ni = start,side.to-side.dir,side.dir do
--            lo('??___________________ni:'..ni)
--        local v = anode[ni+side.dir] - (ni > 1 and anode[ni-side.dir] or anode[1])
		local ipre = ni-side.dir
		if ni == side.fr then
			ipre = ni
--            lo('!!!!!!!!!!! '..ni)
--            return
		end
--            lo('?? for_ipre:'..ni..':'..ipre..':'..side.to..':'..side.fr)
		local v = (ni == side.to and anode[ni] or anode[ni+side.dir]) - anode[ipre] -- (ni > 1 and anode[ni-side.dir] or anode[1])
--        local v = anode[ni+side.dir] - (ni == side.fr and anode[side.fr] or anode[ni-side.dir])
		vp = vec3(-v.y,v.x):normalized()
		d = U.toLine(U.proj2D(p), {U.proj2D(anode[ni]), U.proj2D(anode[ni] + vp)})
		pos = vp:cross(p - anode[ni]).z > 0 and -1 or 1
				if dbg then
					lo('?? for_ni:'..ni..':'..pos..':'..d)
				end
--            lo('?? p2side:'..tostring(ni)..':'..tostring(pos))
		if pos == -1 then
			-- distance to line
--            local d = U.toLine(p, {anode[ni], anode[ni] + vp})
			if dprev then
					if dbg then lo('?? dd:'..ni..':'..dprev..':'..d) end
--                    out.ayel = {anode[ni],anode[ni] + vp}
--                    out.acyan = {p}
				s = dprev/(dprev + d)
				prd = anode[ipre]*(1 - s) + anode[ni]*s
			else
				-- set to start
				prd = anode[start]
				s = 0
			end
--                    out.ayel = {prd} -- {anode[ni]}
			return prd,ni,(1-s)
--[[
		elseif ni == side.to-side.dir then
			-- set to end
			lo('?? ifEnd:'..)
			return
]]
		end
--            out.agreen[#out.agreen + 1] = anode[ni]
		dprev = d
	end
--            if true then return end
	-- last node
	local ni = side.to
--        lo('?? for_NI:'..ni..tostring(anode[ni])..':'..tostring(vp))
	if vp then
		d = U.toLine(p, {anode[ni], anode[ni] + vp})
		pos = vp:cross(p - anode[ni]).z > 0 and -1 or 1
	--        U.dump(side, '?? for_last:'..d..':'..pos..':'..dprev..' ni:'..ni)
		if pos < 0 then
			s = dprev/(dprev + d)
		else
			-- set to end
			s = 1
		end
		prd = anode[ni - side.dir]*(1 - s) + anode[ni]*s
		return prd,ni,(1-s)
	end
end


-- distance of point projection from side start
local function distOnSide(p, side)
	if not p then return end
	local prd,ni,s = p2side(p, side)
	return  p2dist(side, ni, s)
end


local function forStem(side, tip)
	local dir = side.to > side.fr and 1 or -1
	local corner = (tip == 0 and adec[side.rd].list[side.fr] or adec[side.rd].list[side.to])
	if tip == 0 then
		return (adec[side.rd].list[side.fr + dir] - corner):normalized()
	else
		return (adec[side.rd].list[side.to - dir] - corner):normalized()
	end
end


-- point at a given margin with distance d from side start
local function dist2base(d, side, mrg)
	if not mrg then mrg = margin end
		U.dump(side, '>> dist2base:'..d)
	local n2d = D.node2edge(scenetree.findObjectById(adec[side.rd].id))
	local anode = adec[side.rd].list
	for ni = side.fr+side.dir,side.to,side.dir do
		local last = side.dir < 0 and n2d[side.fr].d or 0
		if last + side.dir * n2d[ni].d > d then
				lo('?? hit:'..ni..':'..side.dir..':'..last)
--                out.ayel = {anode[ni],anode[ni-side.dir]}
			local s = side.dir*(d - (last + side.dir*n2d[ni-side.dir].d))/(n2d[ni].d - n2d[ni-side.dir].d)
			local p = anode[ni-side.dir]*(1-s) + anode[ni]*s
			local vt = (anode[ni] - anode[ni-side.dir]):normalized()
			local wd = editor.getNodes(scenetree.findObjectById(adec[side.rd].id))[ni].width
			return p + vec3(-vt.y,vt.x)*(mrg + wd/2)
		end
	end
	-- trim to end
	local vt = (anode[side.to] - anode[side.to-side.dir]):normalized()
	local wd = editor.getNodes(scenetree.findObjectById(adec[side.rd].id))[side.to].width

	return anode[side.to] + vec3(-vt.y,vt.x)*(mrg + wd/2)
end


local function forCorner(sfr, sto)
--        out.awhite = {adec[sto.rd].list[sto.fr]}
	local dstart = 0
	-- distance to match prev side
--    local anobj = editor.getNodes(scenetree.findObjectById(adec[sto.rd].id))
	local wd = anobj[sto.fr].width
		U.dump(sfr, '>> forCorner:'..wd)
	local anode = adec[sto.rd].list
	local v = anode[sto.fr+sto.dir] - anode[sto.fr]
	local w = vec3(-v.y,v.x):normalized() * (wd + margin + mm_depth[1])
	local pc,ang = line2side({anode[sto.fr]+w,anode[sto.fr+sto.dir]+w}, sfr)
	if pc then
		if ang > math.pi/2 then
			dstart = (pc - anode[sto.fr]):dot(forStem(sto,0))
			local wfr = editor.getNodes(scenetree.findObjectById(adec[sfr.rd].id))[sfr.to].width
			dstart = dstart + (margin+wfr/2)/math.cos(ang - math.pi/2)
		end
--            lo('?? for_ang:'..ang..':'..dstart)
--            out.ayel = {pc}
	end
	-- defaul corner
	ang = U.vang(forStem(sfr, 1),forStem(sto, 0))
--        lo('?? cmp_dist:'..ang..':'..dstart..'/'..((margin + wd/2)/math.tan(ang/2))..':'..(margin + wd/2))
	return dist2base(math.max(dstart, (margin + wd/2)/math.tan(ang/2)), sto)
end


local function sideWidth(side, ni, dplus, ano)
	if not dplus then dplus = 0 end
	if not ano then ano = anobj end
--    local ano = anobj
--        lo('?? for_ano2:'..tostring(ano)..':'..tostring(side))
	if not anobj and side then
		ano = editor.getNodes(scenetree.findObjectById(adec[side.rd].id))
--        lo('?? for_ano:'..tostring(ano))
	end
	return margin + ano[ni].width/2 + dplus
end

local atype = {'L','T','P','B','V'}

local function seed(base, side, dma, tp)
--            if #abase == 3 then out.agreen = {base[1]} end
	if not tp then tp = 'B' end
--        out.agreen = {base[#base]}
--        out.acyan = base

--    local rd = scenetree.findObjectById(adec[side.rd].id)
	local anode = adec[side.rd].list
	local n2d = D.node2edge(scenetree.findObjectById(adec[side.rd].id))
	local L = U.rand(mm_len[1], mm_len[2])
	if _DBG then
		L = aLen[clen]
		clen = clen + 1
	else
		aLen[#aLen+1] = L
	end
	if not L then L = U.rand(mm_len[1], mm_len[2]) end
--        if #abase == 3 then L = 10 end
	acLen[#acLen + 1] = L
		U.dump(side, '>>--------------- seed: L='..tostring(L)..' dma:'..tostring(dma)..':'..tostring(tp)..' nbase:'..#abase..' nside:'..#aswitch..':'..#base..':'..tostring(_DBG))
--        lo('?? for_length:'..tostring(dn2d[side.rd][side.dir>0 and side.to or side.fr].d))
--        lo('?? for_seed:'..)
--        U.dump(n2d, '?? anode:'..L)
--        out.acyan = {p}
	local iend
	local function forSide(base)
		local p = base[#base]
		local pfr, dfr, pto, bnxt, spre
		for ni = side.fr+side.dir,side.to,side.dir do
			local last = side.dir < 0 and n2d[side.fr].d or 0
			-- last + side.dir*
			-- start on side
			local s = closestLinePoints(
				anode[ni-side.dir], anode[ni],
				p, p+vec3(0,0,1)
			)
			if not pfr then
				--            if #abase == 5 then
	--            lo('?? for_s:'..tostring(s)..'/'..tostring(spre)..' ni:'..ni)
				--            end
				if s < 0 and spre and spre > 1 and not pfr then
					pfr = anode[ni-side.dir]
					dfr = last + side.dir*n2d[ni-side.dir].d
	--                    lo('?? for_fr1:'..ni..':'..dfr..':'..n2d[4].d)
	--                    if #abase == 3 then
	--                            out.awhite = {pfr} -- {anode[ni-side.dir], anode[ni]}
	--                    end
		--            out.agreen = {anode[ni-side.dir]}
--                        lo('?? DFR1:'..dfr..':'..L)
				elseif 0 <= s and s < 1 and not pfr then
					pfr = anode[ni-side.dir]*(1-s) + anode[ni]*s
					dfr = (last + side.dir*n2d[ni-side.dir].d)*(1-s) + (last + side.dir*n2d[ni].d)*s
--                        lo('?? DFR:'..dfr..':'..L)
	--                        if #abase == 3 then
	--                            out.awhite = {pfr} -- {anode[ni-side.dir], anode[ni]}
	--                        end
		--                out.ayel = {anode[ni-side.dir], anode[ni]}
	--                        lo('?? for_fr2:'..dfr..'/'..(last + side.dir*n2d[side.to].d)..' s:'..s..':'..n2d[side.to].d..':'..n2d[side.fr].d)
		--[[
		]]
				end
				if dfr then
					local remains = (last + side.dir*n2d[side.to].d) - dfr
					if dma and dma - dfr < remains then
--                            lo('?? reREM:'..(dma - dfr))
						remains = dma - dfr
					end
	--                        lo('??__ REM:'..remains)
					if remains < mm_len[1] then
						-- no space left
						lo('!! NO_space_LEFT:'..remains..':'..#base)
						return base
					elseif remains < L then
						L = U.rand(mm_len[1], remains)
							if _DBG then L = (mm_len[1] + remains)/2 end
							lo('?? seed_resized:'..L..'/'..remains)
					end
				end
			end
			spre = s
			-- end on side
	--                if pfr then
	--                    lo('?? for_last:'..L..':'..ni..':'..(ni-side.dir)..':'..(last + side.dir*n2d[ni].d)..'/'..(dfr + L)..':'..tostring(dfr))
	--                end
			if pfr and (last + side.dir*n2d[ni].d) > (dfr + L) then
				s = side.dir*((dfr + L) - (last + side.dir*n2d[ni-side.dir].d))/(n2d[ni].d - n2d[ni-side.dir].d)
	--                lo('?? for_to:'..side.dir..':'..ni..':'..(ni-side.dir)..':'..s..':'..last)
				pto = anode[ni-side.dir]*(1-s) + anode[ni]*s
				local vt = (anode[ni] - anode[ni-side.dir])
				bnxt = pto + vec3(-vt.y, vt.x):normalized() * (p - pfr):length()
				base[#base + 1] = bnxt
				iend = ni - side.dir
				return base

	--                out.agreen = {pto,bnxt}
	--                out.ayel = {anode[ni-side.dir], anode[ni]}

	--                out.ayel = {pto, bnxt} -- {anode[ni-side.dir], anode[ni]}
--                break
			end
		end
	end
	base = forSide(base)
	if not base or #base < 2 then -- bnxt then
		-- trim to end
		lo('!! seed_END:'..#abase)
		return base,tp
	end

	local depthma = forDepth(base[#base-1],base[#base])
--            out.acyan = {base[#base-1], base[#base]}
--            lo('?? dpma:'..depthma)
	local nit = 1
	if true then
		while depthma < mm_depth[1] + 0.1 and nit < 10 do
			local v = (base[#base] - base[#base - 1]):normalized()
			table.remove(base,#base)
			local p = base[#base] + v*5
			local prd,ni,s = p2side(p, side)
			base[#base] = prd + U.perp(anode[ni] - anode[ni - side.dir]):normalized()*sideWidth(side, ni)
--                out.acyan = {base[#base], prd}
--            base[#base] = p2dist(side, ni, s)
			base = forSide(base)
			if not base or #base < 2 then -- bnxt then
				-- trim to end
				lo('!! seed_END: nit='..nit..' abase:'..#abase)
				return base,tp
			end
			--        U.dump(base, '?? for_base:'..#abase)
			depthma = forDepth(base[#base-1],base[#base]) --, true)
--                U.dump(base, '?? for_DEPTH:'..tostring(depthma)..':'..sideWidth(side, ni))
--                out.acyan = {base[#base-1], base[#base]}
--                break
			nit = nit + 1
		end
	end
--    lo('?? depthma:'..tostring(depthma))

	local depth = U.rand(mm_depth[1], math.min(mm_depth[2],depthma))
		if _DBG then depth = math.min(mm_depth[2],depthma) end -- mm_depth[2] end
--    depth = math.min(mm_depth[2],depthma)


	local v = base[#base] - base[#base - 1]
	local w = vec3(-v.y, v.x):normalized()*depth
	abound[#abase+1] = {v,w}
--        U.dump(abound, '?? abound:'..#abound)

	if true and tp == 'B' and depth > mm_depth[1] + (mm_depth[2] - mm_depth[1])/2 then
		tp = atype[math.random(1,2)]
		if _DBG then tp = 'T' end
--        lo('??_______________________________________________ for_v_w:'..#base)
--        tp = 'L'
		base = {base[1]}
	end

	if tp == 'B' then
		base[#base + 1] = base[#base] + w
		base[#base + 1] = base[#base] - v
	elseif tp == 'L' then
		local aw = {U.rand(0.3, 0.7)}
		local av = {U.rand(0.3,0.7)}

		base[#base + 1] = base[#base] + v
		base[#base + 1] = base[#base] + w*aw[1]
		base[#base + 1] = base[#base] - v*av[1]
		base[#base + 1] = base[#base] + w*(1 - aw[1])
		base[#base + 1] = base[#base] - v*(1 - av[1])
	elseif tp == 'T' then
--        lo('?? for_T:'..#base..':'..v:length())
		local aw = {U.rand(0.3, 0.7)}
		local av = {U.rand(0.2,0.3), U.rand(0.3,0.4)}
		if _DBG then
			aw = {0.5}
			av = {0.25, 0.35}
		end
		base[#base + 1] = base[#base] + v
		base[#base + 1] = base[#base] + w*aw[1]
		base[#base + 1] = base[#base] - v*av[1]
		base[#base + 1] = base[#base] + w*(1 - aw[1])
		base[#base + 1] = base[#base] - v*av[2]
		base[#base + 1] = base[#base] - w*(1 - aw[1])
		base[#base + 1] = base[#base] - v*(1 - (av[1] + av[2]))
	elseif tp == 'P' then
	end
			lo('<< seed:'..(base[2]-base[1]):length())
	return base,tp,iend
end


-- find point on side having 'd' free space above for existing buildings
local function fromDepth(d, side, dir)
--        lo('>> fromDepth:')
	if not dir then dir = -1 end
	local fr,to,step = 1,#abase,1
	local ppre,dpre,pa
	local agreen = {}
	for i = fr,to,step do
		local base = abase[i]
		local ishift = 0
		if i == fr then
			ishift = 1
		end
--            lo('?? for_i:'..i..':'..ishift..':'..(#base+ishift)..'>'..(#base+dir)..':'..dir)
		for j = #base+ishift,#base+dir,dir do
			local p = base[(j-1) % #base + 1]
			local prd,ni,s = p2side(p, side)
--                    U.dump(side, '?? for_p:'..i..':'..j..':'..tostring(p)..':'..(p - prd):length()..'/'..d)
			if (p - prd):length() > d then
				agreen[#agreen + 1] = {s = dpre, p = ppre}
--                    lo('?? for_green:'..i..':'..j..':'..#agreen..':'..tostring(ppre))
				if not ppre then
					pa = p
				else
					pa = p*(1-s) + ppre*s
				end
--                break
			else
--                    lo('?? for_red:'..i..':'..j..':'..tostring(ppre))
				agreen = {}
			end
			if #agreen == 2 then
--                    U.dump(agreen, '?? fromDepth_DONE:')
				if not agreen[1].p then
					return
				else
--                            out.agreen = {agreen[2].p}
--                            out.ayel = {agreen[1].p}
--                            out.awhite = {(agreen[1].p*agreen[2].s + agreen[2].p*agreen[1].s)/(agreen[1].s + agreen[2].s)}
					return (agreen[1].p*agreen[2].s + agreen[2].p*agreen[1].s)/(agreen[1].s + agreen[2].s)
				end
			end
			ppre = p
			dpre = math.abs((p - prd):length() - d)
--            spre = s
		end
	end
--[[
		lo('?? fromDepth:'..tostring(pa))
	if pa then
			out.agreen = {pa}
		local dma = distOnSide(pa, side)
			lo('?? dist:'..tostring(dma))
		local prd = p2side(pa, side)
			out.acyan = {prd}
	end
]]
end


local function sidePush(side, parity) --, dist, parity)
	if not parity then parity = 1 end
			U.dump(side, '>> sidePush:'..parity..':'..#aswitch)
--            out.ayel = {}
--            out.awhite = {}
--    local anobjthem = editor.getNodes(scenetree.findObjectById(adec[sfr.rd].id))
	-- go along buildings
	local corner
	local ppre,nipre,pa,defpre,ptpre
	local anode = adec[side.rd].list
	local fr,to,step = #abase,1,-1
	if parity == -1 then
		fr,to,step = 1,#abase,1
	end
			lo('?? FTS:'..fr..':'..to..':'..step)
--            if #abase > 0 then
--                out.awhite = {abase[fr][1]}
--            end
	local iside,tonext = 1
	for i = fr,to,step do
--    for i = #abase,1,-1 do
--                lo('?? for_base:'..i..':'..#abase[i]..':'..tostring(tonext))
		if tonext and (tonext - i)/parity < 0 then
			goto cont
		else
			tonext = nil
		end
		local ishift = (#abase[i] - 4)/2
		local prd,ni,s,def
--        local found = false
		local vlist = parity == 1 and {abase[i][3 + ishift], abase[i][4 + ishift]} or {abase[i][4 + ishift], abase[i][3 + ishift]}
		for _,p in pairs(vlist) do
			prd,ni,s = p2side(p, side, side.fr)
--                out.ayel[#out.ayel + 1] = p
--                out.awhite[#out.awhite + 1] = prd
--                lo('?? to_check:'..i..':'.._..':'..U.proj2D(p - prd):length()..'/'..sideWidth(side, ni, mm_depth[2]))

			def = math.abs(U.proj2D(p - prd):length() - sideWidth(side, ni, mm_depth[2]))
			if U.proj2D(p - prd):length() < sideWidth(side, ni, mm_depth[2]) then
--                        lo('?? for_yel:'..i..':'.._)
--                        out.ayel[#out.ayel + 1] = p
--                        out.ayel[#out.ayel + 1] = prd
				corner = prd
			else --if corner then
--                    lo('?? for_green:'.._..':'..ni..':'..s..':'..tostring(corner)..' d:'..def..' dpre:'..tostring(defpre))
--                local last = side.dir < 0 and n2d[side.fr].d or 0
--                last + side.dir
--                out.acyan = {prd}

--                out.agreen = {ppre}

--                    out.awhite = {ppre}
--                        out.agreen = {p}
					lo('?? sPush:'..forStem(side, 1):dot(vlist[2]-vlist[1]))
				if parity < 0 and not tonext and forStem(side, 1):dot(vlist[2]-vlist[1]) < 0 then
					-- goto next branch
					for k = 1,#aswitch do
						if aswitch[k] >= i then
							tonext = aswitch[k] + 1
							U.dump(aswitch, '??------------------------------------ switching:'..i..'>'..tonext)
							break
						end
					end
--                    tonext = i + 5*step
--                    U.dump(aswitch, '??------------------------------------ switching:'..i..'>'..tonext)
					goto cont
				end
				if defpre and corner then
					local cs = def/(def + defpre)
					corner = ppre*cs + prd*(1 - cs)
	--                    out.awhite = {corner}
	--                        lo('?? for_w:'..ni..':'..tostring(sideWidth(side, ni)))
					corner = corner + U.proj2D(p - prd):normalized()*sideWidth(side, ni)
	--                    out.acyan = {corner}
						lo('?? pre_CC:'..ni..'<'..nipre..':'..side.dir..':'..side.fr..' cs='..cs..':'..s)
	--                found = true
					local v
					if ni == side.fr then
						if s == 0 then return end
						v = anode[ni+side.dir] - anode[ni]
					else
						v = anode[ni] - anode[ni - side.dir]
					end
					-- distance from start
					local dma
					if parity == -1 then
							U.dump(side, '?? preDIST:'..tostring(corner)..':'..ni..':'..(ni-side.dir))
						if ni == side.fr then --and s == 1 then
							dma = 0
						else
							local onroad,nist,sst = p2side(corner, side, ni == side.fr and ni or ni-side.dir)
							local last = side.dir < 0 and n2d[side.fr].d or 0
							dma = (last + side.dir*n2d[nist - side.dir].d)*s + (last + side.dir*n2d[nist].d)*(1-s)
						end
					end

	--                dir = (prd - ppre):dot(v) > 0 and 1 or -1
	--                    U.dump(side, '?? for_CORNER:'..tostring(ni)..':'..side.dir..':'..s)
	--                    out.acyan = {corner}
						lo('<< sidePush:'..nipre..'>'..ni..':'..tostring(dma))
					return corner, parity*v:normalized(), dma, (p-ptpre):normalized()
				else
					return
--                    return prd + U.proj2D(p - prd):normalized()*sideWidth(side, ni), vec3()
				end
--                break
	--            return corner +
			end
--                out.acyan = {ppre}
			ppre,nipre,defpre,ptpre = prd,ni,def,p
			pa = p
		end
--            out.awhite[#out.awhite + 1] = prd
--        p = abase[i][4 + ishift]
--        prd,ni,s = p2side(p, side, side.fr)
--            out.awhite[#out.awhite + 1] = prd
		::cont::
	end
	if corner and ppre then
--            out.acyan = {ppre,pa}
			lo('?? for_C:'..tostring(corner)..':'..tostring(pa)..':'..tostring(ppre))
		corner = corner + (pa - ppre):normalized()*sideWidth(side, nipre)
--        out.acyan = {corner}
		if nipre == side.fr then return end
		local v
		if nipre == side.fr then
			v = anode[nipre+side.dir] - anode[nipre]
		else
			v = anode[nipre] - anode[nipre - side.dir]
		end

		return corner, parity*v:normalized(), dma --(anode[nipre]-anode[nipre-side.dir]):normalized()
	end
end


local function branchPush(sfr, sto, dfr, dto, parity, anobjthem)
	if not parity then parity = 1 end
--            U.dump(sfr, '>> branchPush:'..parity)
--    if not dist then dist = margin + anobj[ni].width/2 + mm_depth[2] end
	if not anobjthem then
		anobjthem = editor.getNodes(scenetree.findObjectById(adec[sfr.rd].id))
	end
--            out.agreen = {}
--            out.ayel = {}
	local sadj = sfr
	local side = sto
	local igreen, ired, dgreen, dred, pgreen, pred = sadj.fr
--    dgreen = 0

	local ifr, ito, dir = sadj.fr, sadj.to, sadj.dir
	if parity < 0 then
		ifr, ito, dir = sadj.to, sadj.fr, -sadj.dir
	end
	for nj = ifr+dir,ito,dir do
--    for nj = sadj.fr+sadj.dir,sadj.to,sadj.dir do
		local anode = adec[sadj.rd].list
		-- get repelling point
		local v = anode[nj] - anode[nj-dir]
--        local v = anode[nj] - anode[nj-sadj.dir]
		local vt = vec3(-v.y,v.x):normalized()
		local p = anode[nj] + parity*vt*dfr
--        local p = anode[nj] + dir*vt*dfr --(1 + margin + anobjthem[nj].width/2 + mm_depth[2])
--                        out.agreen[#out.agreen + 1] = anode[i]

		local prd,ni,s = p2side(p, side, side.fr) --, nj == 1 and true or false)
--                lo('?? for_prd:'..nj..':'..tostring(prd)..':'..tostring(ni)..':'..tostring(s))
--                        lo('?? for_node:'..sadj.rd..':'..nj..':'..tostring(prd))
--                    out.awhite[#out.awhite + 1] = prd
		local d = 0
		if prd then
			d = dto - (p - prd):length()
		end
		if prd and d > 0 then
--                        out.ayel[#out.ayel + 1] = p
--                        lo('?? red:'..tostring(nj)..'/'..tostring(igreen))
--            if igreen and not ired then
			if not ired then
--                    out.ayel = {p}
--                    lo('?? FT:'..(ifr+dir)..'>'..ito..':'..nj)
				ired = nj
				dred = math.abs(d)
				pred = p
			end
		else
--                        out.agreen[#out.agreen + 1] = p
--                        lo('?? green:'..tostring(nj))
			igreen = nj
			dgreen = math.abs(d)
			pgreen = p
			ired = nil
		end
	end
--        lo('?? fro_RG:'..tostring(ired)..':'..tostring(igreen)..':'..tostring(dgreen)..':'..tostring(dred))
	local p
	if ired then
		if igreen and dred and dgreen then
--        out.ayel = {pred}
--        out.agreen = {pgreen}
			local s = dgreen/(dgreen + dred)
	--            lo('?? SET:'..i..':'..s..':'..tostring(ired)..':'..tostring(igreen)..':'..tostring(anobj[ired]))
			p = pgreen*(1-s) + pred*s
		else
			p = pred
		end
	end
	return p,igreen,ired
end


local function forLimit(side, sthem, parity, dplus)
	if not dplus then dplus = 0 end
		lo('>> forLimit:'..parity)
	-- in-area point
	local anobjus = editor.getNodes(scenetree.findObjectById(adec[side.rd].id))
	local anobjthem = editor.getNodes(scenetree.findObjectById(adec[sthem.rd].id))
	local p,igreen,ired = branchPush(sthem, side,
		margin + anobjthem[sthem.to].width/2 + dplus,
		margin + anobjus[side.fr].width/2 + mm_depth[2], parity)
						lo('?? for_p:'..tostring(p)..':'..dplus)
--                        out.acyan = {p}
--                        out.agreen = {}
--                        out.ayel = {}
	-- on-road projection point
	if p then
		local d,dto
		local prd,ni,s = p2side(p, side, side.fr)
		local node_dist = n2d
		if not node_dist then
			node_dist = D.node2edge(scenetree.findObjectById(adec[side.rd].id))
		end
		local last = side.dir < 0 and n2d[side.fr].d or 0
--            U.dump(side,'?? forLimit:'..ni..':'..tostring(node_dist[ni - side.dir])..':'..tostring(node_dist[ni]))
		if ni - side.dir < #node_dist then
			d = (last + side.dir*node_dist[ni - side.dir].d)*s + (last + side.dir*node_dist[ni].d)*(1-s)
		end
		if ni ~= side.fr then
			-- projection lift to margin
			return prd + (margin + anobjus[ni].width/2)*(p - prd):normalized(), d
		end
	end
end
--            dto = node_dist[side.to].d - d
--            lo('?? for_dist:'..s..':'..node_dist[ni - side.dir].d..'>'..node_dist[ni].d)
--                        out.awhite = {corner}
--                            lo('?? for_ni:'..ni..':'..s..':'..tostring(d))

--[[
		if false then
			if i > 1 then
				sideprev = aside[i - 1]
				-- check position of previous boxes
				local cc,v = sidePush(side)
					lo('?? prev_BR:'..i..':'..tostring(cc)..':'..tostring(v))
				if cc then
					corner = cc + v*3   -- shift by 3 from ending corner
	--                out.acyan = {cc}
	--                if i == 5 then return end
				end
	--                lo('?? prev_BR2:'..i..':'..tostring(corner))
	--                out.awhite = {corner}
	--                if true then return end
			else
				-- push from previous on-map road
				local stem = cornerPrev(side)
				if stem then
					local fr = stem.ndi > stem.fr and #adec[stem.rdi].list or 1
					sideprev = {rd = stem.rdi, fr = fr, to = stem.fr, dir = stem.fr>fr and 1 or -1}
						U.dump(sideprev, '?? IF_CORNER:')
					local anobjprev = editor.getNodes(scenetree.findObjectById(adec[sideprev.rd].id))
	--                    lo('?? for_PREV:'..tostring(anobjprev[side.fr]))
	--                    if true then return end
					local p,igreen,ired = branchPush(sideprev, side,
						margin + anobjprev[sideprev.to].width/2,
						mm_depth[2] + margin + anobj[side.fr].width/2)
	--                        lo('?? for_p:'..tostring(p))
	--                        out.acyan = {p}
	--                        out.agreen = {}
	--                        out.ayel = {}
					if p then
						local prd,ni = p2side(p, side, side.fr)
	--                        out.awhite = {corner}
	--                        lo('?? for_ni:'..ni..':'..side.fr)
						if ni ~= side.fr then
							corner = prd + (margin + anobj[ni].width/2)*(p - prd):normalized()
						end
					end
	--                        out.awhite = {corner}
	--                        if true then return end
				end
			end
		end
		local function p2corner(ppushed, corner)
			local prd,nip = p2side(ppushed, side)
			if nip ~= side.fr then
				if corner then
					local crd,nic = p2side(corner, side)
					-- TODO: use s
					if (nip - nic)/side.dir > 0 then
						corner = nil
					end
		--            out.agreen = {crd}
				end
				if not corner and prd then
					corner = prd + (ppushed - prd):normalized()*sideWidth(side,nip)
				end
			end
			return corner
		end
		if false and #aside > 1 then --and  i < #aside then
			-- get side end limit pushed by next branch
			local cc,v,d,vnode = sidePush(side, -1)
			if d then
				dma = d
--                dma = d - 3
			end
		end

			-- for previous box corner
			local p = base[#base]
			if #abase > 0 then
				local basepre = abase[#abase]
				for i = #basepre/2,#basepre/2+1 do
					local s = closestLinePoints(basepre[i], basepre[i+1], p, p + vec3(0,0,1))
					if 0 <= s and s < 1 then
						local def = (p - (basepre[i]*(1-s) + basepre[i+1]*s)):length() - drepell
					end
				end
			end

			if false and ishift == 0 and pbound then
				local valong = (base[2+ishift]-base[1+ishift]):normalized()
				local basepre = abase[#abase]
				-- TODO: V shapes
				local ishiftpre = (#basepre - 4)/2
				if valong:dot(basepre[2+ishiftpre] - basepre[1+ishiftpre]) > 0 then
					local shift = (pbound - base[1+ishift]):dot(valong)
					--                    out.ayel = {base[1],base[2],base[3],base[4]}
					if shift > 0 then
						-- shift along the road
						for k = 1,#base do
							base[k] = base[k] + valong*shift
						end
							lo('?? SHIFTED_along:'..shift..':'..tostring(pbound))
					end
				end
			end
--                out.ayel = {base[1],base[2]}
			-- check distance to road
			local pproj = p2side(base[2+ishift], side, inprev)
			if false and pproj then
--                    out.agreen = {base[2+ishift]}
					lo('?? for_def:'..inprev..':'..#base..':'..ishift..':'..tostring(pproj))
				local dft = (margin + anobj[inprev].width/2) - (base[2+ishift] - pproj):length()
				if dft > 0 then
				-- shift vertices from road
					local w = (base[3+ishift] - base[2+ishift]):normalized()
					base[1+ishift] = base[1+ishift] + w*dft
					base[2+ishift] = base[2+ishift] + w*dft
				end
					lo('?? SHIFTED_perp:'..dft)
--                    out.agreen = {pproj}
			end

		if false then
			-- TODO: check other sides
--                U.dump(sideprev, '?? sprev:')
			local anthem = editor.getNodes(scenetree.findObjectById(adec[sideprev.rd].id))
			local ppushed = branchPush(sideprev, side,
				sideWidth(sideprev, sideprev.to, 0, anthem), sideWidth(side, side.fr, mm_depth[2]))
			local prd,nip = p2side(ppushed, side)
--                out.acyan = {prd}
--                out.ayel = {ppushed}
			if nip ~= side.fr then
				if corner then
					local crd,nic = p2side(corner, side)
					if (nip - nic)/side.dir > 0 then
						corner = nil
					end
		--            out.agreen = {crd}
				end
				if not corner and prd then
					corner = prd + (ppushed - prd):normalized()*sideWidth(side,nip)
				end
			end
		end
--            out.acyan = {prd}
]]
--                    out.acyan = {base[1],base[2]}
			--******** CORRECT POSITION
			-- check distance to next branch
--[[
			local tonext = false
			if #aside > 1 then
				local asnxt = {aside[i % #aside + 1]}
				for _,sidenxt in pairs(asnxt) do
					local dplus = (i >= #aside - 1) and mm_depth[2] or 0
					for _,bc in pairs({base[2 + ishift], base[3 + ishift]}) do
						local prd = p2side(bc, sidenxt, sidenxt.fr)
						if prd then
							local d = (bc - prd):length()
	--                            lo('?? to_road:'.._..':'..d..':'..dplus)
							if d < (dplus + margin + anobjnxt[sidenxt.fr].width/2) then
								-- to next branch
									out.agreen = {prd}
								tonext = true
								break
							end
						end
					end
				end
			end
			-- TODO:
			if true and tonext then
				lo('!! BREAK_nxt_branch_close:'..i..':'..n)
					out.acyan = base
--                        out.apath = {abase[#abase]}
--                        if true then return end
				break
			end
]]

local function pave(asd)
		U.dump(aside, '>> pave:')
	if asd then aside = asd end
	if not aside then return end
		out.ayel = {}
		out.awhite = {}
		out.acyan = {}
		out.agreen = {}
		out.apath = {}
	acLen = {}
	aswitch = {}

	if not _DBG then
		aLen = {}
		clen = 1
	end

	local pbound
	local space
--    for i = 1,1 do
	for i = 1,#aside do
		if i > #aside then
			lo('!! NO_SIDE:')
			return
		end
		-- ===========================================
		-- SWITCH SIDE
		-- ===========================================
		aswitch[#aswitch + 1] = #abase
		anobj = editor.getNodes(scenetree.findObjectById(adec[aside[i].rd].id))
		local sidenxt = aside[i % #aside + 1]
		local anobjnxt = editor.getNodes(scenetree.findObjectById(adec[sidenxt.rd].id))
		local side = aside[i]
			U.dump(side, '??****************** SIDE:'..i..'/'..#aside..':'..aside[i].rd..':'..#abase)
			U.dump(adec[aside[i].rd])
		n2d = D.node2edge(scenetree.findObjectById(adec[side.rd].id), true)
		local anode = adec[side.rd].list
		local corner,dma = forCorner(aside[(i - 2) % #aside + 1], aside[i])
--            out.agreen = {corner}

		local ddef = distOnSide(corner, side)

		if true or i == 1 then
			-- PUSH from PREV BRANCHES
			local stem = cornerPrev(side)
			if stem then
				local fr = stem.ndi > stem.fr and #adec[stem.rdi].list or 1
				local sideprev = {rd = stem.rdi, fr = fr, to = stem.fr, dir = stem.fr>fr and 1 or -1}
				--- check empty side push
				local sideprev = side
				local dm,pm = 0
				for k = 1,2 do
					local stem = cornerPrev(sideprev)
					if stem then
						local fr = stem.ndi > stem.fr and #adec[stem.rdi].list or 1
						sideprev = {rd = stem.rdi, fr = fr, to = stem.fr, dir = stem.fr>fr and 1 or -1}
						local anthem = editor.getNodes(scenetree.findObjectById(adec[sideprev.rd].id))
						local ppushed = branchPush(sideprev, side,
							sideWidth(sideprev, sideprev.to, 0, anthem), sideWidth(side, side.fr, mm_depth[2]))
--                            lo('?? ppu:'..tostring(ppushed))
		--                        out.acyan = {ppushed}
						local cdist = distOnSide(ppushed, side)
						if cdist and cdist > dm then
							dm = cdist
							pm = ppushed
						end
					end
		--                lo('?? forPM:'..k..':'..tostring(pm)..':'..tostring(dm)..'/'..ddef)
				end
					lo('?? DM_pu:'..tostring(dm))
				if dm and dm > ddef then
					lo('?? corner_pushed:'..dm)
					corner = dist2base(dm, side)
				end
			end
		end

		-- NEXT EMPTY BRANCH CHECK
		local ppushed = branchPush(sidenxt, side,
			sideWidth(sidenxt, sidenxt.to, 0, anobjnxt), sideWidth(side, side.fr, mm_depth[2]), -1)
--        corner = p2corner(ppushed, corner)
--            out.acyan = {ppushed}
				lo('?? ppu_next:'..tostring(ppushed))
		if ppushed then
			local prd,nip,sip = p2side(ppushed, side)
	--            lo('?? pp:'..tostring(ppushed)..':'..nip..':'..sip..':'..tostring(dma))
	--            out.agreen = {prd}
			local cdma
			if nip ~= side.fr then
				local d = p2dist(side, nip, sip)
				if d then
					if dma then
						if d < dma then
							dma = d
						end
					else
						dma = d
					end
				end
			end
		end
		-- CHECK TAIL BOX
		if #abase > 0 and i == #aside then
			-- 1st building last corner
			local bbase = abase[1]
			if abound[1] then
				bbase = {bbase[1]}
				bbase[#bbase + 1] = bbase[#bbase] + abound[1][1]
				bbase[#bbase + 1] = bbase[#bbase] + abound[1][2]
				bbase[#bbase + 1] = bbase[#bbase] - abound[1][1]
			end
			local cdma = distOnSide(bbase[#bbase], side)
--            local cdma = distOnSide(abase[1][#abase[1]], side)
				lo('?? ON_SIDE:'..tostring(cdma))
			if dma then
				if cdma and cdma < dma then dma = cdma end
			else
				dma = cdma
			end
		end

		if true or i == #aside then
			-- check push from filled branch
			local pa = fromDepth(mm_depth[1] + sideWidth(side, side.to), side)
			if pa then
					U.dump(side, '?? for_dma:'..i..':'..tostring(pa))
--                    out.ayel = {pa}
				local prd,ni,s = p2side(pa, side)
--                    out.acyan = {prd}
				if ni == side.fr then
					dma = 0
				else
					local cdma = distOnSide(pa, side)
					if dma then
						if cdma and cdma < dma then dma = cdma end
					else
						dma = cdma
					end
				end
			end
		end

--                U.dump(aside[(i - 2) % #aside + 1], '?? for_CC:'..tostring(corner)..':'..tostring(dma))
				--!!
--                corner = nil
--[[
		if not corner then
			-- default corner
			corner = forCorner(aside[(i - 2) % #aside + 1], aside[i])
		end
			out.agreen = {corner}
]]
--            if true then return end
		-- ===========================================
		-- GO ALONG ROAD
		-- ===========================================
		local base,tp,inprev
		local n = 1
		while n < 200 do
--                        lo('?? pregr:'..i..':'..#abase..':'..n)
--                        out.agreen = {corner}
				base,tp,inprev = seed({corner}, aside[i], dma)
					if i == 5 and n == 1 then
--                        out.acyan = {base[1],base[2],base[3],base[4]}
--                        out.apath[#out.apath + 1] = base
--                        return
					end
--                    U.dump(base, '?? BASE:'..#abase)
--                    U.dump(abound, '?? ABOUND:'..#abase)
			if not base or #base < 4 then
				lo('!! NO_BASE:'..i..'/'..#aside..':'..n)
				break
			end
			-- get bounding box
			local bbase = U.clone(base)
			if abound[#abase+1] then
				bbase = {bbase[1]}
				bbase[#bbase + 1] = bbase[#bbase] + abound[#abase+1][1]
				bbase[#bbase + 1] = bbase[#bbase] + abound[#abase+1][2]
				bbase[#bbase + 1] = bbase[#bbase] - abound[#abase+1][1]
			end
			local ishift = tp == 'V' and 1 or 0

			-- shift from next
			--********** NEXT BASE CORNER
			space = U.rand(mm_space[1], mm_space[2])
				if _DBG then space = 2 end
--                space = 2

			local function proj2dist(list)
				local dma = 0
				for _,p in pairs(list) do
					local prd,ni,s = p2side(p, side)
					local d = p2dist(side, ni, s)
					if d > dma then dma = d end
				end
			end

			--- check curvature
			local curv
			local icurv
			if inprev == side.to - side.dir then
				curv = 0
			else
				local last = side.dir < 0 and n2d[side.fr].d or 0
				local d0 = last + side.dir*n2d[inprev+side.dir].d
				for i = inprev+2*side.dir,side.to,side.dir do
--                        lo('?? for_nd:'..i..':'..(last + side.dir*n2d[i].d)..'/'..d0)
					if math.abs((last + side.dir*n2d[i].d) - d0) > mm_len[2] then
						icurv = i
						break
					end
				end
				if not icurv then icurv = side.to end
--                        lo('?? i_curv:'..tostring(icurv)..':'..(inprev+2*side.dir))
				curv = (bbase[2] - bbase[1]):cross(anode[icurv] - anode[inprev+side.dir]).z
			end
--                U.dump(side, '?? for_curv:'..i..':'..n..' inprev:'..inprev..' curv:'..curv)
			if curv < 0 then
				-- CONCAVE CORNER
--                    out.ayel = {anode[inprev]}
--                    lo('?? CONC:'..#abase)
				local v = (anode[inprev+2*side.dir] - anode[inprev]):normalized()
					lo('?? for_CONC: i:'..i..' n:'..n)
				corner = bbase[2+ishift] + v*space
--                    out.awhite = {corner}
			else
				-- CONVEX CORNER
--                    lo('?? for_CONV:'..n..':'..#abase..':'..tostring(icurv)..'/'..inprev)
--                local nilast,slast
				local prd,ni
				if icurv and icurv ~= inprev+2*side.dir then
					pbound = bbase[3+ishift] + space*(anode[icurv] - anode[inprev+2*side.dir]):normalized()
					for j = inprev,icurv,side.dir do
--                            lo('?? for_j:'..j..':'..tostring(pbound))
--                        p2side(pbound, side, j, true)
						local cprd,cni,s = p2side(pbound, side, j)
--                                lo('?? for_sss:'..j..':'..tostring(s))
						if cprd and s > 0 and s < 1 then
--                            inprev = ni
							prd = cprd
							ni = cni
						end
--                        lo('?? for_s:'..j..':'..tostring(ni)..':'..tostring(s))
					end
				else
					pbound = bbase[3+ishift] + space*(bbase[2+ishift] - bbase[1+ishift]):normalized()
--                            lo('?? for_prd:'..ishift)
--                            out.agreen = {}
--                            out.agreen = {bbase[1], base[1] + abound[#abase][2]}
					prd,ni = p2side(pbound, aside[i], inprev)
					if not prd then
						-- end of side, to next side
							lo('!! BREAK_end_of_side:')
						abase[#abase + 1] = base
						break
					end
				end
				if prd and anobj and anobj[ni] then
--                        lo('?? for_pp:'..tostring(prd)..':'..tostring(anobj[ni])..':'..tostring(pbound))
					corner = prd + (margin + anobj[ni].width/2)*(pbound - prd):normalized()
				else
					lo('!! ERR_no_anobj:'..tostring(ni))
				end
--                    out.ayel[#out.ayel+1] = corner
			end
--                out.ayel[#out.ayel+1] = corner
--                out.ayel = {corner}
--            corner = prd + ()

--            ::continue::
			--**************** APPEND BASE
			abase[#abase + 1] = base
				lo('??+++++++++++ to_base:'..i..':'..#abase)
			out.apath[#out.apath+1] = base

				if i == 6 and n == 1 then
--                    break
				end
			n = n + 1
		end
	end
	out.apath = {}
	for _,b in pairs(abase) do
		out.apath[#out.apath + 1] = b
	end
		local s = ''
		for _,a in pairs(acLen) do
			s = s..','..a
		end
--            local ppp,ni,s = p2side(abase[#abase][1], aside[4], aside[4].fr)
--            U.dump(aside[4], '?? for_s:'..ni..':'..s..':'..(n2d[aside[4].fr].d - n2d[7].d))
--            out.awhite = {abase[#abase][1], ppp}
		lo('<< pave:'..#abase)
		lo(s)
end
--[[
				if cc and i == 4 then
--                    out.acyan = {cc}
--                    out.awhite = {cc+v}
					local ppp,ni,s = p2side(cc, side, side.fr)
--                    out.awhite = {ppp}
--                    U.dump(n2d, '?? DMA:'..tostring(dma)..':'..tostring(ni)..':'..tostring(s)..':'..(n2d[side.fr].d - n2d[ni].d))
--                    dma = 130
				end
--                lo('?? DMA:'..tostring(dma)..':'..tostring(vnode))
--                if i == 4 then return end
			local dplus = i == #aside and mm_depth[2] or 0
			local prd, d = forLimit(side, aside[i % #aside +1], -1, dplus)
			dma = d
					U.dump(aside[i+1], '?? for_PRD:'..tostring(prd)..' dma:'..tostring(dma))
]]
--                    out.awhite = {prd}
--                    if i == 2 then return end
--[[
			local p,igreen,ired = branchPush(aside[i+1], side,
				margin + anobjnxt[aside[i+1].fr].width/2,
				margin + anobj[side.to].width/2 + mm_depth[2], -1)
				U.dump(side, '??__________ pushed_for_1st:'..tostring(p))
			local prd = p2side(p, side)
					out.acyan = {p}
]]
--                    out.awhite = {prd}
	--                corner = p
--                    if true then return end

--[[
			if false then
				local dma = 0
				for j = i-1,1,-1 do
						lo('?? for_j:'..j)
					local p,d = forLimit(side, aside[j], 1, mm_depth[2])
						lo('??___________ PD:'..tostring(p)..':'..tostring(d)..'/'..dma)
					if d and d > dma then
						dma = d
						corner = p
							out.awhite = {corner}
					end
				end
			end
]]
--                    out.awhite = {prd}

--                    if true then return end
--            break

--                n2d[inprev+2*side.dir]
--                    curv = (base[2] - base[1]):cross(anode[inprev+2*side.dir] - anode[inprev+side.dir]).z
--                    out.agreen = {anode[icurv], anode[inprev+side.dir]}
--                    local pbn = base[3+ishift] + space*(base[2+ishift] - base[1+ishift]):normalized()
--                    local prd,ni = p2side(pbn, aside[i], inprev)
--                    out.acyan = {prd}
--                    out.awhite = {pbn}
--                curv = (anode[inprev+side.dir] - anode[inprev]):cross(anode[inprev+2*side.dir] - anode[inprev+side.dir]).z

--[[
					if #abase == 10 then
						--break
					end
					if i == 4 then
						out.apath = {base}
--                        out.acyan = {base[1]}
						return
					end
					if #abase == 9 then
						out.agreen = {base[1],base[2],base[3],base[4]}
						lo('?? TO_BREAK:'..i)
--                        return
--                        break
					end
]]

--[[
			local v = forStem(side, 0)
					U.dump(v, '?? for_PREV:')
--                    if true then return end
--                out.agreen = {}
--                out.awhite = {}
--                out.ayel = {}
			local dma, pma, nima, boxma, ima = 0
			local ibreak
			local last = side.dir < 0 and n2d[side.fr].d or 0
			local igreen, ired, dgreen, dred, pred, pgreen
			local asadj = {} -- adjacent side
			if i > 2 then
				asadj[#asadj + 1] = aside[i - 2]
			end
			asadj[#asadj + 1] = aside[i - 1]
			for _,sadj in pairs(asadj) do
				local anobjthem = editor.getNodes(scenetree.findObjectById(adec[sadj.rd].id))
				local n2dthem = D.node2edge(scenetree.findObjectById(adec[sadj.rd].id))
				igreen = sadj.fr
				for nj = sadj.fr+sadj.dir,sadj.to,sadj.dir do
					local anode = adec[sadj.rd].list
					-- get repelling point
					local v = anode[nj] - anode[nj-sadj.dir]
					local vt = vec3(-v.y,v.x):normalized()
					local p = anode[nj] + vt*(1 + margin + anobjthem[nj].width/2 + mm_depth[2])
--                        out.agreen[#out.agreen + 1] = anode[i]

					local prd,ni,s = p2side(p, side, side.fr)
--                        lo('?? for_node:'..sadj.rd..':'..nj..':'..tostring(prd))
	--                    out.awhite[#out.awhite + 1] = prd
					local d = 0
					if prd then
						d = margin + anobj[ni].width/2 + mm_depth[2] - (p - prd):length()
					end
					if prd and d > 0 then
--                            out.ayel[#out.ayel + 1] = p
--                            lo('?? red:'..tostring(nj)..'/'..tostring(igreen))
						if igreen and not ired then
							ired = nj
							dred = math.abs(d)
							pred = p
						end
					else
--                        lo('?? green:'..tostring(nj))
--                        out.agreen[#out.agreen + 1] = p
						igreen = nj
						dgreen = math.abs(d)
						pgreen = p
						ired = nil
					end
				end

				if ired and igreen and dgreen then
--                    out.ayel = {pred}
--                    out.agreen = {pgreen}
					local s = dgreen/(dgreen + dred)
						lo('?? SET:'..i..':'..s..':'..tostring(ired)..':'..tostring(igreen)..':'..tostring(anobj[ired]))
					local p = pgreen*(1-s) + pred*s
					pma = p2side(p, side, side.fr)
--                        out.awhite = {pma}
					corner = pma + (p - pma):normalized()*(margin + anobjthem[ired].width/2)
--                        out.acyan = {corner}
					break
				else
					-- next side
				end
					lo('?? iRG:'..tostring(ired)..':'..tostring(igreen)..':'..tostring(dred)..':'..tostring(dgreen))
			end

			if false and pma then
				corner = pma + (boxma - pma):normalized()*(margin + anobj[ima].width/2)
					out.acyan = {corner} --{pma} --baselast[ima]}
					lo('?? ___------'..i..':'..#abase)

					if i == 4 then
					end
			else
			if not corner then
				-- check hangover of previous box
				local angside = U.vang(forStem(side, 0), forStem(aside[i-1],1))
				local curvside = forStem(aside[i-1],1):cross(forStem(side, 0)).z
						lo('?? scurv:'..angside..':'..curvside..':'..tostring(space))
				if curvside < 0 then
					-- convex
					local prd,ni = p2side(pbound, aside[i], side.fr)
						lo('?? prd:'..tostring(prd)..':'..tostring(ni)..':'..side.fr)
					if prd and ni ~= side.fr then
							lo('?? TO_shift:')
						corner = prd + (margin + anobj[ni].width/2)*(pbound - prd):normalized()
	--                else
	--                        lo('?? TO_default:')
	--                    corner = forCorner(aside[(i - 2) % #aside + 1], aside[i])
					end
	--                out.agreen = {corner}
				else
					-- TODO: concave
				end
			end
]]

--[[
			local sideprev
			if #aside == 1 then
				local stem = cornerPrev(side)
					U.dump(stem, '?? stem:'..#aside)
				local fr = stem.ndi > stem.fr and #adec[stem.rdi].list or 1
				sideprev = {rd = stem.rdi, fr = fr, to = stem.fr, dir = stem.fr>fr and 1 or -1}
			else
				sideprev = aside[#aside]
			end
			local anobjthem = editor.getNodes(scenetree.findObjectById(adec[sideprev.rd].id))
			local p = branchPush(sideprev, side,
				margin + anobjthem[sideprev.to].width/2,
				margin + anobj[side.fr].width/2 + mm_depth[2])
--                    U.dump(sideprev, '?? sideprev:'..(p - anode[side.fr]):dot(forStem(side, 0)))
--                    out.ayel = {p}
--                if true then return end
			if p and (p - anode[side.fr]):dot(forStem(side, 0)) > 0 then
				local prd,ni = p2side(p, side, side.fr)
				corner = prd + (margin + anobj[ni].width/2)*(p - prd):normalized()
					lo('?? for_p:'..tostring(p))
--                    out.ayel = {prd}
			end

			local fr,to = stem.fr, dir>0 and #adec[stem.rdi].list or 1
--                    lo('?? for_next: rdi='..stem.rdi..':'..stem.fr..'>'..dir..':'..ind..' fr:'..fr..' to:'..to)
			for k = fr,to,dir do
				if k == akey[ind + dir] then
--                    lo('?? nxr_crn:'..stem.rdi..':'..k)
					acorner[#acorner+1] = {rd = stem.rdi, to = k, fr = fr, dir = (k > fr and 1 or -1)}
					break
				end
			end
]]

--            local sprev = {rd = stem.rdi, to = k, fr = fr, dir = (k > fr and 1 or -1)}
--                    U.dump(sprev, '?? cprev:')
--            local p = branchPush(cprev, side)
--                return


local function forRoads(p, odec)
	if odec then D = odec end
--    if U._PRD == 1 then return end
		lo('>> forRoads:'..#D.out.adec)
	local dmi,rmi,nmi = math.huge
	if #D.out.adec == 0 then
		D.decalsLoad()
	end
	adec = D.out.adec
	across = D.out.across
--        lo('?? forRoads:'..#adec)
	-- get bounding roads
	--- find closest edge
	for ind,r in pairs(adec) do
		for i = 1,#r.list-1 do
			local d = U.proj2D(p):distanceToLineSegment(U.proj2D(r.list[i]), U.proj2D(r.list[i+1]))
--                if ind == 1 and i == 1 then lo('?? dd:'..tostring(d)) end
			if d < dmi then
				dmi = d
				rmi = ind
				nmi = i
			end
		end
	end
--    local L = W.out.L
--        U.dump(across[rmi], '??____________ mi: nmi='..nmi..' dmi:'..dmi..' rmi:'..tostring(rmi)) --..':'..tostring(across[rmi])) --tostring(adec[rmi].list[nmi])..':'..tableSize(across)) --..':'..tostring(adec[rmi].list[nmi])..':'..tostring(adec[rmi].list[nmi+1])..':'..tostring(p))
--        local grid = 10
--        local n = adec[rmi].list[1] --#adec[rmi].list]
--        out.apick = {adec[rmi].list[nmi]}
--        local i,j = math.floor((n.y + L)/grid) + 1,math.floor((n.x + L)/grid) + 1
--        lo('?? ij:'..i..':'..j..':'..tostring(across[i]))
	if rmi and across[rmi] and adec[rmi] then
		--- sort nodes
		local akey = {}
		for key,_ in pairs(across[rmi]) do
			akey[#akey+1] = key
		end
		table.sort(akey)
--            U.dump(akey, '?? akey:'..nmi)
		local ib,ie
		for i,key in pairs(akey) do
--                lo('?? for_key:'..key..'/'..nmi)
			if key > nmi then
				ib = akey[i-1]
				ie = akey[i]
				break
			end
		end
		local dir = (adec[rmi].list[nmi] - p):cross(adec[rmi].list[nmi+1] - p).z
--                lo('?? pre1st:'..ie..':'..ib..':'..dir)
--        local ib,ie = 1,#adec[rmi].list
		if dir < 0 then
			dir = -1
			local sib = ib
			ib = ie
			ie = sib
		else
			dir = 1
		end
--            U.dump(akey, '?? sorted:'..dir..':'..ib..'>'..ie)

		--- go around
		local function cornerNext(c, dir)
			if not dir then dir = c.dir end
			local ri,ni = c.rd,c.to
--                U.dump(across[ri][ni], '>> cornerNext:'..ri..':'..ni..' dir:'..dir)
			local astem,us = U.clone(across[ri][ni])
			astem[#astem + 1] = {ri, ni}
			local star = U.forStar(astem, adec)
--                U.dump(star, '?? star:'..#star..':'..dir)

			for i,s in pairs(star) do
--                        U.dump(s, '?? for_stem:'..i)
				if s.rdi == ri and s.ndi == s.fr + dir then
--                    U.dump(s, '?? for_nxt:'..i)
					-- take prev branch
					return star[(i-2) % #star + 1]
				end
			end
			return
		end

		local acorner = {}
		if ie and ib then

			acorner = {{rd = rmi, to = ie, fr = ib, dir = (ie > ib and 1 or -1)}}
			dn2d[rmi] = D.node2edge(scenetree.findObjectById(adec[rmi].id))
--                U.dump(acorner, '?? first_side:'..rmi)
	--            if true then return end
			for i = 1,10 do
				local stem = cornerNext(acorner[#acorner], -dir)
	--                    U.dump(stem,'?? next_stem:'..i)
	--                    if i > 2 then return end
				if stem.rdi == acorner[1].rd then
	--            if not stem then
					lo('!! BREAK_same_stem:')
	--                        if true then return end
					break
				end
	--                U.dump(stem, '?? nxt:'..i..':'..stem.rdi)
	--                U.dump(across[stem.rdi], '?? cross:'..i)
				akey = {}
				for key,_ in pairs(across[stem.rdi]) do
					akey[#akey+1] = key
				end
				table.sort(akey)
				dir = stem.ndi - stem.fr
	--                U.dump(akey, '?? sorted:'..dir..':'..stem.fr)
				local ind = U.index(akey, stem.fr)[1] --table.index_of(akey, stem.ndi)
				-- get next cross
				local fr,to = stem.fr, dir>0 and #adec[stem.rdi].list or 1
	--                    lo('?? for_next: rdi='..stem.rdi..':'..stem.fr..'>'..dir..':'..ind..' fr:'..fr..' to:'..to)
				local hasnext = false
				for k = fr,to,dir do
					if k == akey[ind + dir] then
--                        lo('?? nxr_crn:'..stem.rdi..':'..k)
						acorner[#acorner+1] = {rd = stem.rdi, to = k, fr = fr, dir = (k > fr and 1 or -1)}
						dn2d[stem.rdi] = D.node2edge(scenetree.findObjectById(adec[stem.rdi].id))
						hasnext = true
						break
					end
				end
				if not hasnext then
					lo('!! BREAK_is_open_end:'..i..':'..stem.rdi)
					break
				end
			end

		end

				U.dump(acorner, '??________ acorner:'..#acorner)
		out.avedit = {}
		for _,p in pairs(acorner) do
			out.avedit[#out.avedit + 1] = adec[p.rd].list[p.to]
--!!
			D.matApply('road_asphalt_unmarked', scenetree.findObjectById(adec[p.rd].id))
		end
			lo('<< forRaods:'..#out.avedit)
		if odec then
			out.inpick = acorner
		end
		return acorner
	end
end


local function populate(acrs, adecal, odec, oworld, cancel, pt)
		lo('>>++++++++++++++++++++++++++ populate:'..tostring(cpoint)..':'..tostring(out.inpave))
	if out.inpave or cancel == true then
		out.inpave = nil
		out.avedit = {}
		abase = {}
		aside = {}
		out.apath = nil
		return
	end
--        if true then return end
--    if
	if pt then cpoint = pt end
	if not cpoint then return end
--        if true then return end
	across = acrs
	abase = {}
	adec = adecal
	if not _DBG then
		aLen,clen = {},1
		aSpace,cspace = {},1
	end
--        U.dump(across[1][1], '?? pop:'..tableSize(across))
	D = odec
	W = oworld
	local p = cpoint -- cameraMouseRayCast().pos
--        U.dump(adec[133], '?? pop_adec:'..tableSize(adec)..':'..tostring(p))
--    out.avedit = {}

	local acorner = forRoads(p)

	-- pave with polygons
	pave(acorner)
	out.inpave = true
	W.scopeOn(nil)
		lo('?? paved:'..#abase)


--[[

	local dmi,rmi,nmi = math.huge
	-- get bounding roads
	--- find closest edge
	for ind,r in pairs(adec) do
		for i = 1,#r.list-1 do
			local d = U.proj2D(p):distanceToLineSegment(U.proj2D(r.list[i]), U.proj2D(r.list[i+1]))
--                if ind == 1 and i == 1 then lo('?? dd:'..tostring(d)) end
			if d < dmi then
				dmi = d
				rmi = ind
				nmi = i
			end
		end
	end
--    local L = W.out.L
		U.dump(across[rmi], '??____________ mi: nmi='..nmi..' dmi:'..dmi..' rmi:'..tostring(rmi)..':'..tostring(adec[rmi].list[nmi])..':'..tableSize(across)) --..':'..tostring(adec[rmi].list[nmi])..':'..tostring(adec[rmi].list[nmi+1])..':'..tostring(p))
--        local grid = 10
		local n = adec[rmi].list[1] --#adec[rmi].list]
--        out.apick = {adec[rmi].list[nmi]}
--        local i,j = math.floor((n.y + L)/grid) + 1,math.floor((n.x + L)/grid) + 1
--        lo('?? ij:'..i..':'..j..':'..tostring(across[i]))
	if across[rmi] then
		--- sort nodes
		local akey = {}
		for key,_ in pairs(across[rmi]) do
			akey[#akey+1] = key
		end
		table.sort(akey)
--            U.dump(akey, '?? akey:'..nmi)
		local ib,ie
		for i,key in pairs(akey) do
--                lo('?? for_key:'..key..'/'..nmi)
			if key > nmi then
				ib = akey[i-1]
				ie = akey[i]
				break
			end
		end
		local dir = (adec[rmi].list[nmi] - p):cross(adec[rmi].list[nmi+1] - p).z
--                lo('?? pre1st:'..ie..':'..ib..':'..dir)
--        local ib,ie = 1,#adec[rmi].list
		if dir < 0 then
			dir = -1
			local sib = ib
			ib = ie
			ie = sib
		else
			dir = 1
		end
--            U.dump(akey, '?? sorted:'..dir..':'..ib..'>'..ie)

		--- go around
		local function cornerNext(c, dir)
			if not dir then dir = c.dir end
			local ri,ni = c.rd,c.to
--                U.dump(across[ri][ni], '>> cornerNext:'..ri..':'..ni..' dir:'..dir)
			local astem,us = U.clone(across[ri][ni])
			astem[#astem + 1] = {ri, ni}
			local star = U.forStar(astem, adec)
--                U.dump(star, '?? star:'..#star..':'..dir)

			for i,s in pairs(star) do
--                        U.dump(s, '?? for_stem:'..i)
				if s.rdi == ri and s.ndi == s.fr + dir then
--                    U.dump(s, '?? for_nxt:'..i)
					-- take prev branch
					return star[(i-2) % #star + 1]
				end
			end
			return
		end

		local acorner = {{rd = rmi, to = ie, fr = ib, dir = (ie > ib and 1 or -1)}}
		dn2d[rmi] = D.node2edge(scenetree.findObjectById(adec[rmi].id))
			U.dump(acorner, '?? first_side:'..rmi)
--            if true then return end
		for i = 1,10 do
			local stem = cornerNext(acorner[#acorner], -dir)
--                    U.dump(stem,'?? next_stem:'..i)
--                    if i > 2 then return end
			if stem.rdi == acorner[1].rd then
--            if not stem then
				lo('!! BREAK_same_stem:')
--                        if true then return end
				break
			end
--                U.dump(stem, '?? nxt:'..i..':'..stem.rdi)
--                U.dump(across[stem.rdi], '?? cross:'..i)
			akey = {}
			for key,_ in pairs(across[stem.rdi]) do
				akey[#akey+1] = key
			end
			table.sort(akey)
			dir = stem.ndi - stem.fr
--                U.dump(akey, '?? sorted:'..dir..':'..stem.fr)
			local ind = U.index(akey, stem.fr)[1] --table.index_of(akey, stem.ndi)
			-- get next cross
			local fr,to = stem.fr, dir>0 and #adec[stem.rdi].list or 1
--                    lo('?? for_next: rdi='..stem.rdi..':'..stem.fr..'>'..dir..':'..ind..' fr:'..fr..' to:'..to)
			local hasnext = false
			for k = fr,to,dir do
				if k == akey[ind + dir] then
					lo('?? nxr_crn:'..stem.rdi..':'..k)
					acorner[#acorner+1] = {rd = stem.rdi, to = k, fr = fr, dir = (k > fr and 1 or -1)}
					dn2d[stem.rdi] = D.node2edge(scenetree.findObjectById(adec[stem.rdi].id))
					hasnext = true
					break
				end
			end
			if not hasnext then
				lo('!! BREAK_is_open_end:'..i..':'..stem.rdi)
				break
			end
		end

				U.dump(acorner, '??________ acorner:'..#acorner)
		out.avedit = {}
		for _,p in pairs(acorner) do
			out.avedit[#out.avedit + 1] = adec[p.rd].list[p.to]
--!!                D.matApply('road_asphalt_unmarked', scenetree.findObjectById(adec[p.rd].id))
		end


		-- pave with polygons
		pave(acorner)
		out.inpave = true
			lo('?? paved:'..#abase)
--            U.dump(across[i][j], '?? sorted:'..i..':'..j)
	else
			U.dump(adec[rmi], '!! NO_CROSS:'..tostring(rmi)..':'..tostring(n))
--            U.dump(nil, '?? ij:'..i..':'..j..':'..tostring(across[i]))
	end
]]
--                if true then return end
--[[
		out.avedit = {
			U.proj2D(adec[rmi].list[nmi])+vec3(0,0,core_terrain.getTerrainHeight(U.proj2D(adec[rmi].list[nmi]))),
			U.proj2D(adec[rmi].list[nmi+1])+vec3(0,0,core_terrain.getTerrainHeight(U.proj2D(adec[rmi].list[nmi+1]))),
		}
]]
end


local function onSpacing(v)
	lo('>> onSpacing:'..v)
	if v == 0 then
		lo('?? for_DENSE:')
		return
	end
	ui.spacing = v
	mm_space = {v, 2*v}
	abase = {}
	pave()
end


local function build()
	lo('>> build:'..#abase)
	out.apath = nil
	for i = 1,#abase do
		local base = {}
		local p = abase[i][1]
		for k = 1,#abase[i] do
			base[#base + 1] = abase[i][k] - p
			base[#base].z = 0
		end
		lo('??********************************** pre_BUILD:')
		W.buildingGen(p, base, true)
	end
end


local function markUp(list, rma, clr)
	if not list then return end
	for _,p in pairs(list) do
		local r = rma * math.sqrt((p - core_camera.getPosition()):length())
		p.z = core_terrain.getTerrainHeight(U.proj2D(p))
		debugDrawer:drawSphere(p, r, clr)
	end
end


local function onUpdate(inj)
	D = inj.D
--    if true then return end
	local rayCast = cameraMouseRayCast(false)
	if im.IsMouseClicked(0) and rayCast then
		if im.IsWindowHovered(im.HoveredFlags_AnyWindow) or im.IsAnyItemHovered() then
			return
		end
		if rayCast.object.name ~= 'theTerrain' then return end
			lo('??_ region_CLICK:'..rayCast.object.name..':'..tostring(cpoint))
		if editor.keyModifiers.ctrl then return end
		cpoint = rayCast.pos
--        populate()
		out.apick = {cpoint}
	elseif rayCast and im.IsMouseReleased(0) then
--            lo('?? R.upd:'..tostring(rayCast.object.name))
		if editor.keyModifiers.shift and rayCast.object.name == 'theTerrain' then
			local ard = forRoads(cpoint)
			if ard then
				out.inpick = ard
			end
		end
	end
	if im.IsKeyPressed(im.GetKeyIndex(im.Key_Enter)) and out.inpave then
--        lo('??+++++++++++++++++++++++++++++++++++++++++++++++ region_to_GEN:'..#abase..':'..tostring(out.inpave))
		if #abase > 0 then
			build()
			out.inpave = nil
		end
	end


	markUp(out.avedit, 0.1, ColorF(1,1,1,0.5))
	markUp(out.apick, 0.05, ColorF(0,1,1,0.7))

	markUp(out.ayel, 0.05, ColorF(1,1,0,1))
	markUp(out.awhite, 0.05, ColorF(1,1,1,1))
	markUp(out.acyan, 0.05, ColorF(0,1,1,1))
	markUp(out.agreen, 0.05, ColorF(0.1,1,0.1,1))

	if out.apath ~= nil then
		for _,p in pairs(out.apath) do
			for i = 2,#p do
				debugDrawer:drawLine(p[i-1], p[i], ColorF(1,0,0,1))
			end
			-- close path
			debugDrawer:drawLine(p[#p], p[1], ColorF(1,0,0,1))
		end
	end

end


local mantle = 5
local inmantle = false

local function conform(desc, hplus)
--[[
	if true then
		local x,y = -220,1025

		tb:setHeightWs(vec3(x,y), 0)
		lo('?? 0_0 : h='..core_terrain.getTerrainHeight(vec3(x,y)))

		lo('?? -1_0 : '..core_terrain.getTerrainHeight(vec3(x-1,y)))
		lo('?? +1_0 : '..core_terrain.getTerrainHeight(vec3(x+1,y)))
		lo('?? 0_-1 : '..core_terrain.getTerrainHeight(vec3(x,y-1)))
		lo('?? 0_+1 : '..core_terrain.getTerrainHeight(vec3(x,y+1)))

		tb:setHeightWs(vec3(x,y), 1)
		lo('?? 0_0 : h='..core_terrain.getTerrainHeight(vec3(x,y)))

		lo('?? -1_0 : '..core_terrain.getTerrainHeight(vec3(x-1,y)))
		lo('?? +1_0 : '..core_terrain.getTerrainHeight(vec3(x+1,y)))
		lo('?? 0_-1 : '..core_terrain.getTerrainHeight(vec3(x,y-1)))
		lo('?? 0_+1 : '..core_terrain.getTerrainHeight(vec3(x,y+1)))

		tb:setHeightWs(vec3(x,y), 0)
		lo('?? 0_0 : h='..core_terrain.getTerrainHeight(vec3(x,y)))

		lo('?? -1_0 : '..core_terrain.getTerrainHeight(vec3(x-1,y)))
		lo('?? +1_0 : '..core_terrain.getTerrainHeight(vec3(x+1,y)))
		lo('?? 0_-1 : '..core_terrain.getTerrainHeight(vec3(x,y-1)))
		lo('?? 0_+1 : '..core_terrain.getTerrainHeight(vec3(x,y+1)))

		return
--        tb:setHeightWs(vec3(x,y), 5)
	end
]]



	if desc == nil then desc = adesc[cedit.mesh] end
	if desc == nil then return end
	if hplus == nil then hplus = 0 end
		lo('?? CONF:'..#adec)
	if true or U._mode ~= 'GEN' then
		restore()
		if #adec == 0 then
--        if true or tableSize(editor.getAllRoads()) ~= #adec then
				lo('?? to_update:'..tableSize(editor.getAllRoads())..'/'..#adec) --..' L:'..L, true)
--                L = 4096

--??			adec,aref,L = D.decalsLoad() --L, grid)
--??			L = L/2

	--            U.dump(aref, '?? updated:'..tostring(aref))
	--            U.dump(adec, '?? adec:'..#adec)
		end
	end
		lo('>>++++++++__________ conform:'..L..':'..tableSize(adec)..':'..tableSize(aref)..':'..#aref..':'..tostring(U._mode))
--        U.dump(aref, '?? AREF:')
--    if tableSize(adec)
--    shmap = {}
--        if true then return end
--    local ndecal = editor.getDecalTemplates():size()
--        lo('?? ndec:'..tostring(out.inconform)) --tostring(Engine.Render.DecalMgr.getSet())) --..tostring(Engine.Render.DecalMgr.getClosestDecal(vec3(0,0,0)))) --..tostring(editor.getDecalInstance(1)))

	local margin = 1.1
	-- get limiting circle (with margin)
	local pos = vec3(desc.pos.x, desc.pos.y)
	local base = desc.afloor[1].base
	-- building center
	local c = vec3(0,0,0)
	for _,p in pairs(base) do
		c = c + p
	end
	c = c/#base
	local r = 0
	local adist = {}
	for i,p in pairs(base) do
		local a,b = base[i] + desc.pos,base[i % #base + 1] + desc.pos
		adist[#adist + 1] = c:distanceToLineSegment(a, b)
		if (p - c):length() > r then
			r = (p - c):length()
		end
	end
	r = r + mantle
	local hasnodes = tableSize(aref) > 0
	c = c + pos
	local hbase = desc.pinned and desc.pos.z or core_terrain.getTerrainHeight(c) + hplus --+ 10
	-- get mantle
			out.avedit = {}
			U.dump(desc.afloor[1].base, '>> conform: pos = '..tostring(desc.pos)..' c:'..tostring(c)..' hbase:'..hbase..':'..tostring(indrag)) --..':'..desc.id)
			out.apoint = {c + vec3(0, 0, hbase + W.forHeight(desc.afloor) + 0.0)}
			out.apick = {}
--        lo('?? R:'..r..' h:'..hbase..' c:'..tostring(c))
	local xmima, ymima = {math.huge, 0},{math.huge, 0}
			lo('?? X_lim:'..tostring(math.floor(c.x - r))..':'..tostring(math.ceil(c.x + r)), true)
			lo('?? Y_lim:'..math.floor(c.y - r)..':'..math.ceil(c.y + r), true)
	local block = terrainBackup({math.floor(c.x - r), math.ceil(c.x + r)}, {math.floor(c.y - r), math.ceil(c.y + r)})
	for x = math.floor(c.x - r), math.ceil(c.x + r) do
		for y = math.floor(c.y - r), math.ceil(c.y + r) do
--                lo('?? for_H:'..x..':'..y..':'..core_terrain.getTerrainHeight(vec3(x,y)), true)
--                out.avedit[#out.avedit + 1] = vec3(x, y, desc.pos.z + 5)
			local p = vec3(x, y)
--                lo('?? XY:'..x..':'..y)
--                tb:setHeightWs(p, desc.pos.z)
			local dmi,imi = math.huge -- dmi: distanse to base border
			for i = 1,#base do
				local a,b = base[i] + pos,base[i % #base + 1] + pos
--                local dc = p:distanceToLineSegment(a, b)
				local d = p:distanceToLineSegment(U.proj2D(a), U.proj2D(b))
--                    if i == 1 and d <= mantle then
--                        lo('?? for_p:'..tostring(p - pos)..':'..d)
--                    end
--                    lo('?? for_d:'..i..':'..d..':'..tostring(p)..':'..tostring(a)..':'..tostring(b))
				if d < dmi then
					dmi = d
					imi = i
				end
			end

--            if dmi < adist[i] then
			local dir = (p - pos - base[imi]):cross(M.step(base, imi)).z
			local dirpre = (p - pos - U.mod(imi-1, base)):cross(M.step(base, imi-1)).z
			--if imi == 1 and
--            if imi == 2 and
--                hbase = desc.pos.z
			local dh = 0.5
--                out.avedit[#out.avedit + 1] = vec3(x, y, hbase) -- desc.pos.z + 5)
			if dir <= 0 and dirpre <= 0 then
--                    out.avedit[#out.avedit + 1] = vec3(x, y, hbase) -- desc.pos.z + 5)
--                lo('?? step:'..dmi) -- ..tostring(M.step(base, dmi)))
				hmapChange(p, hbase)
--                    out.apick[#out.apick + 1] = vec3(x, y, hbase + dh)
--                    tb:setHeightWs(p, hbase)
			else --if imi == 1 then
--                    lo('?? out:'..imi..':'..dmi..':'..(p-pos):distanceToLineSegment(base[imi], base[imi+1]))
--                    out.avedit[#out.avedit + 1] = vec3(x, y, hbase)
				if dmi < margin then
--                            out.avedit[#out.avedit + 1] = vec3(x, y, hbase + dh) -- desc.pos.z + 5)
					hmapChange(p, hbase)
--                        tb:setHeightWs(p, hbase)
				elseif dmi < margin + mantle then

					-- distance to mantle end, mantle width
					local b,a = margin + mantle - dmi,dmi - margin
--                            tb:setHeightWs(p, h)
--                            if y == 238 then
--                            if y == 231 and x <= -512 then
					out.apick[#out.apick + 1] = vec3(x, y, hbase + dh) -- desc.pos.z + 5)
					-- check decals
					local i,j = math.floor((y + L)/grid),math.floor((x + L)/grid)
--                                lo('?? for_IJ:'..i..':'..j)
					--                                    lo('?? for_cyan: x:'..x..' y:'..y..' ij:'..i..':'..j..' h:'..h..'/'..hbase..':'..hter)
					--- get adjacent grid
					local gmax = math.ceil(2*L/grid)
					local agrid = {}
					for _,a in pairs({-1,0,1}) do
						for _,b in pairs({-1,0,1}) do
							if i+a < 1 or i+a > gmax or j+b < 1 or j+b > gmax then
							else
								agrid[#agrid+1] = {i+a,j+b}
							end
						end
					end
--                            U.dump(agrid, '?? AGRID:')
--                                    if i > 100 and j > 100 then
--                                        U.dump(aref[i][j],'?? for_agrid:'..i..':'..j..':'..#agrid..':'..x..':'..y)
--                                        U.dump(agrid)
--                                    end
------------------------------
-- DISTANCE TO ROAD
------------------------------
					local drmi = math.huge
					local w
					for _,ij in pairs(agrid) do
--                                        if ij[1] == 101 and ij[2] == 101 then
--                                            U.dump(aref[ij[1]][ij[2]], '?? CHECK:'..tostring(hasnodes))
--                                        end
						if hasnodes and aref[ij[1]] and aref[ij[1]][ij[2]] then
											lo('?? for_NODE:'..ij[1]..':'..ij[2], true)
							for ind,dec in pairs(aref[ij[1]][ij[2]]) do
								local rd = adec[ind].list
								-- TODO: get road width
								w = 4
								local nfr,nto = dec[1],dec[2]
								if dec[1] > 1 then nfr = nfr - 1 end
								if dec[2] < #rd then nto = nto + 1 end
--                                                U.dump(dec, '?? for_dec:'..ind..':'..nfr..':'..nto)
								for k = nfr,nto-1 do
									local d = U.proj2D(p):distanceToLineSegment(U.proj2D(rd[k]), U.proj2D(rd[k+1]))
--                                    if d < drmi then drmi = d end
									if d < w then
										lo('?? on_ROAD:')
										if d < drmi then drmi = d end
--                                                        lo('?? ON_ROAD:'..ind..':'..k)
									end
								end
							end
						end
--                                    U.dump(aref[ij[1]][ij[2]], '?? for_ref:'..ij[1]..':'..ij[2])
					end
--                                    if y == 231 and x <= -512 then
--                        if drmi ~= math.huge and drmi < b then
					if w and drmi < w + 1 then
						-- skip changes
--                            out.avedit[#out.avedit+1] = vec3(x, y, hbase + dh)
					else
--                        lo('?? for_drmi:'..drmi..'/'..b, true)
						if drmi < b then
--zz                                            lo('?? TO_PIN:')
								lo('?? drmi:'..x..':'..y..':'..drmi..'/'..b, true)
--                            b = drmi - 0.1
								out.avedit[#out.avedit+1] = vec3(x, y, hbase + dh)
						end
						local hter = block[x][y] --core_terrain.getTerrainHeight(p)
						local h = U.spline2(hbase, hter, a, a + b)
						hmapChange(p, h)
					end
--                        out.avedit[#out.avedit + 1] = vec3(x, y, hbase) -- desc.pos.z + 5)
				end
			end
--            lo('?? xy:'..imi..':'..dmi..':'..x..':'..y)
		end
	end
		lo('?? conf2:')
	tb:updateGrid()
	out.inconform = true
		lo('??*************************** conf3:'..tostring(inmantle)..':'..desc.id)
--        lo('?? conformed:'..#shmap)
	if not inmantle then
		-- reposition building
		desc.pos.z = hbase
			lo('?? obi:'..tostring(scenetree.findObjectById(desc.id)))
--        for _,s in pairs(dforest) do
--            editor.removeForestItem(fdata, s.item)
--        end
	--        U.dump(desc.afloor[1].awall[1].df, '?? DF:')
	--    W.forestClean(desc)

	--    scenetree.findObjectById(desc.id).hidden = true --:setMeshAlpha(1, "", false)
	--!!
		if #asel > 1 then
			local ind = U.index(asel, desc.id)[1]
			if ind and ind > 1 then
				W.houseUp(adesc[asel[ind-1]], asel[ind-1])
				aedit = {}
				W.houseUp(nil, desc.id)
			else
				W.houseUp(desc, desc.id, true)
			end
		else
			W.houseUp(desc, desc.id, true)
		end
		if #asel > 0 and desc.id == asel[#asel] then
			U.dump(adec, '?? LAST:'..tostring(N.cid)) --adec[17].id)
			D.ter2road(nil, N.cid)
		end
--[[
		if #asel > 0 and desc.id == asel[#asel] then
			lo('?? LAST:')
--            W.houseUp(desc, desc.id)
			W.houseUp(adesc[cedit.mesh], cedit.mesh)
--            markUp()
--            -- clean previous edit
			aedit = {}
--        end

			W.houseUp(nil, desc.id)
			cedit.mesh = desc.id
--            markUp()
		else
			W.houseUp(desc, desc.id, true)
		end
]]
	end
end



R.forRoads = forRoads
R.populate = populate
R.onUpdate = onUpdate
R.onSpacing = onSpacing
R.out = out
R.ui = ui

return R
